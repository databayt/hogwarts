// ============================================
// FINANCE MODULE - Banking Integration
// ============================================

model BankAccount {
  id               String   @id @default(cuid())
  schoolId         String
  userId           String
  bankId           String
  accountId        String
  accessToken      String   @db.Text // Encrypted
  fundingSourceUrl String?
  shareableId      String?
  institutionId    String
  name             String
  officialName     String?
  mask             String?
  currentBalance   Decimal  @db.Decimal(10, 2)
  availableBalance Decimal  @db.Decimal(10, 2)
  type             String // depository, credit, loan, investment
  subtype          String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  school            School               @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  user              User                 @relation("UserBankAccounts", fields: [userId], references: [id], onDelete: Cascade)
  transactions      Transaction[]
  sentTransfers     Transfer[]           @relation("SentTransfers")
  receivedTransfers Transfer[]           @relation("ReceivedTransfers")
  reconciliations   BankReconciliation[]

  @@unique([schoolId, accountId])
  @@index([schoolId])
  @@index([userId])
  @@index([accountId])
}

model Transaction {
  id              String   @id @default(cuid())
  schoolId        String
  accountId       String
  bankAccountId   String
  name            String
  amount          Decimal  @db.Decimal(10, 2)
  date            DateTime
  paymentChannel  String? // online, in_store, other
  category        String
  subcategory     String?
  type            String // debit, credit
  pending         Boolean  @default(false)
  merchantName    String?
  merchantId      String?
  locationAddress String?
  locationCity    String?
  locationState   String?
  locationZip     String?
  locationCountry String?
  isoCurrencyCode String   @default("USD")
  createdAt       DateTime @default(now())

  // Relations
  school      School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  @@index([schoolId])
  @@index([bankAccountId])
  @@index([accountId])
  @@index([date])
  @@index([category])
}

model Transfer {
  id                String   @id @default(cuid())
  schoolId          String
  senderBankId      String
  receiverBankId    String
  amount            Decimal  @db.Decimal(10, 2)
  note              String?
  status            String // pending, completed, failed
  transferDate      DateTime
  dwollaTransferId  String?
  dwollaTransferUrl String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  school       School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  senderBank   BankAccount @relation("SentTransfers", fields: [senderBankId], references: [id])
  receiverBank BankAccount @relation("ReceivedTransfers", fields: [receiverBankId], references: [id])

  @@unique([schoolId, dwollaTransferId])
  @@index([schoolId])
  @@index([senderBankId])
  @@index([receiverBankId])
  @@index([status])
  @@index([transferDate])
}

model PlaidItem {
  id              String   @id @default(cuid())
  schoolId        String
  userId          String
  accessToken     String   @db.Text // Encrypted
  itemId          String
  institutionId   String
  institutionName String
  cursor          String? // For transaction sync
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  school School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  user   User   @relation("UserPlaidItems", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([schoolId, accessToken])
  @@unique([schoolId, itemId])
  @@index([schoolId])
  @@index([userId])
  @@index([itemId])
}

model DwollaCustomer {
  id          String   @id @default(cuid())
  schoolId    String
  userId      String
  customerId  String
  customerUrl String
  status      String // unverified, suspended, retry, document, verified, deactivated
  type        String // personal, business
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  school School @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  user   User   @relation("UserDwollaCustomers", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([schoolId, userId])
  @@unique([schoolId, customerId])
  @@unique([schoolId, customerUrl])
  @@index([schoolId])
  @@index([customerId])
  @@index([status])
}

// Bank Reconciliation
enum ReconciliationStatus {
  IN_PROGRESS
  COMPLETED
  DISCREPANCY
}

model BankReconciliation {
  id               String               @id @default(cuid())
  schoolId         String
  bankAccountId    String
  statementDate    DateTime
  statementBalance Decimal              @db.Decimal(12, 2)
  bookBalance      Decimal              @db.Decimal(12, 2)
  difference       Decimal              @db.Decimal(12, 2)
  status           ReconciliationStatus @default(IN_PROGRESS)
  reconciledBy     String?
  reconciledAt     DateTime?
  notes            String?              @db.Text
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  school      School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id])

  @@index([schoolId, bankAccountId])
  @@index([schoolId, statementDate])
}
