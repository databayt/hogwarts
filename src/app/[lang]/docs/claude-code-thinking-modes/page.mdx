# Claude Code Thinking Modes

Unlock deeper reasoning and better solutions by controlling how much time Claude spends thinking through complex problems before responding.

## What Are Thinking Modes?

Thinking modes control Claude's internal reasoning process, allocating more "thinking time" for complex problems that benefit from careful analysis:

- **Standard Mode** (default): Quick responses for routine tasks
- **Think**: Enhanced reasoning for non-trivial problems
- **Think Hard**: Deep analysis for complex challenges
- **Think Harder**: Extended thinking for architectural decisions
- **Ultrathink**: Maximum reasoning for critical, complex work

**Key Concept**: More thinking time = better planning, fewer mistakes, more thorough solutions.

## How Extended Thinking Works

When you enable extended thinking, Claude:

1. **Analyzes** the problem deeply before responding
2. **Explores** multiple approaches and trade-offs
3. **Plans** the solution in detail
4. **Validates** the approach before execution
5. **Explains** reasoning transparently

You see Claude's thinking process in `<thinking>` tags before the response.

## Thinking Budgets

Each mode has a different thinking budget:

| Mode | Thinking Tokens | Best For | Response Time |
|------|----------------|----------|---------------|
| **Standard** | ~0 | Simple tasks, quick edits | Fastest |
| **Think** | ~5,000 | Code reviews, debugging | Fast |
| **Think Hard** | ~10,000 | Architecture design, refactoring | Medium |
| **Think Harder** | ~20,000 | Complex migrations, optimization | Slower |
| **Ultrathink** | ~50,000+ | Critical systems, algorithms | Slowest |

**Thinking tokens** are separate from output tokens and don't count toward your response limit.

## When to Use Each Mode

### Standard Mode (Default)

Use for routine tasks:

```
# Standard mode (no flag needed)
You: "Add a TODO comment to this function"
You: "Fix this typo in the README"
You: "Run the tests"
```

**Characteristics**:
- Fast responses
- Straightforward tasks
- Well-defined problems
- Minimal planning needed

### Think Mode

Use for tasks requiring analysis:

```
You: "think: Review this PR for potential bugs"
You: "think: Refactor this component to use hooks"
You: "think: Debug why this test is failing"
```

**Best for**:
- Code reviews
- Debugging complex issues
- Refactoring components
- API design
- Test generation

**Example**:

```
You: "think: Why is this component re-rendering unnecessarily?"

<thinking>
Let me analyze the component structure...
1. Component receives props from parent
2. Uses useState for local state
3. Has inline arrow function in onClick
4. Creates new object in render

Potential causes:
- Inline function creates new reference each render
- Parent might be re-rendering
- Props might include new objects

Let me check props and state dependencies...
</thinking>

Claude: The component re-renders because:

1. **Inline function in onClick**: Creates new function reference each render
   ```jsx
   // Current (causes re-renders)
   <button onClick={() => handleClick(id)}>

   // Fixed
   const onClick = useCallback(() => handleClick(id), [id]);
   <button onClick={onClick}>
   ```

2. **Object creation in render**: New object each time
   ```jsx
   // Current
   style={{ padding: 10 }}

   // Fixed
   const style = useMemo(() => ({ padding: 10 }), []);
   ```

Apply these fixes to prevent unnecessary re-renders.
```

### Think Hard Mode

Use for complex problems requiring deep analysis:

```
You: "think hard: Design the architecture for our microservices migration"
You: "think hard: Optimize this algorithm for better performance"
You: "think hard: Review our authentication system for security"
```

**Best for**:
- System architecture
- Performance optimization
- Security audits
- Complex algorithms
- Database schema design
- Migration planning

**Example**:

```
You: "think hard: Design a scalable notification system"

<thinking>
Requirements analysis:
- Real-time notifications
- Multiple notification types (email, SMS, push)
- User preferences
- Delivery guarantees
- Scale to millions of users

Architecture considerations:
1. Message Queue (Kafka/RabbitMQ) - decouple producers/consumers
2. Notification Service - handle delivery
3. Preference Service - manage user settings
4. Template Service - notification content
5. Delivery Tracking - analytics and retries

Trade-offs:
- Synchronous vs Async: Async for scale
- Push vs Pull: Push for real-time
- Storage: PostgreSQL for transactional, Redis for cache

Scaling strategy:
- Horizontal scaling of notification workers
- Partition message queue by user_id
- Cache user preferences in Redis
- Rate limiting per channel

Failure handling:
- Dead letter queue for failed notifications
- Exponential backoff for retries
- Circuit breaker for external services
</thinking>

Claude: Here's the scalable notification architecture:

## Components

1. **Message Queue (Kafka)**
   - Topic per notification type
   - Partition by user_id for ordering
   - Retention: 7 days

2. **Notification Service**
   ```typescript
   interface NotificationService {
     send(notification: Notification): Promise<void>
     retry(failedNotification: Notification): Promise<void>
     track(deliveryStatus: DeliveryStatus): void
   }
   ```

[Detailed implementation plan continues...]
```

### Think Harder Mode

Use for critical, complex work:

```
You: "think harder: Review our entire codebase for security vulnerabilities"
You: "think harder: Plan the database migration from MongoDB to PostgreSQL"
You: "think harder: Design our distributed caching strategy"
```

**Best for**:
- Critical security reviews
- Large-scale migrations
- Distributed systems design
- Complex optimization problems
- Regulatory compliance reviews
- Disaster recovery planning

### Ultrathink Mode

Use for the most complex challenges:

```
You: "ultrathink: Design our global CDN architecture with edge computing"
You: "ultrathink: Plan the migration to event-driven microservices"
You: "ultrathink: Optimize our recommendation algorithm"
```

**Best for**:
- Critical system design
- Advanced algorithms
- Multi-stage migrations
- Complex optimization
- Mission-critical refactoring

**Warning**: Ultrathink is slow. Use only when thoroughness is more important than speed.

## Syntax

### Prefix Syntax (Recommended)

```
think: Your question
think hard: Your question
think harder: Your question
ultrathink: Your question
```

**Examples**:

```
think: Review this PR
think hard: Design the caching layer
think harder: Plan the microservices migration
ultrathink: Architect our distributed system
```

### Command Flag

```bash
claude --think
claude --think-hard
claude --think-harder
claude --ultrathink
```

### Session-Wide Setting

Set for entire session:

```
/model --thinking extended
```

Or in settings.json:

```json
{
  "thinkingMode": "think-hard"
}
```

## Planning Before Coding

Extended thinking excels at planning before implementation:

### Architecture Planning

```
You: "think hard: Before implementing the user authentication system, create a comprehensive plan"

<thinking>
Let me plan this systematically...

Requirements:
- JWT-based authentication
- Social OAuth (Google, GitHub)
- Email/password with 2FA
- Session management
- Role-based access control

Components needed:
1. Auth Service
2. Token Manager
3. Session Store (Redis)
4. User Service
5. RBAC Middleware

Security considerations:
- Password hashing: bcrypt
- Token expiry: 24h access, 7d refresh
- HTTPS only
- CORS configuration
- Rate limiting on auth endpoints

Database schema:
- users table
- sessions table
- oauth_providers table

API endpoints:
- POST /auth/register
- POST /auth/login
- POST /auth/logout
- POST /auth/refresh
- GET /auth/me

Testing strategy:
- Unit tests for auth logic
- Integration tests for flows
- Security tests for vulnerabilities
</thinking>

Claude: Here's the comprehensive authentication system plan:

## Phase 1: Database Schema
[Detailed schema...]

## Phase 2: Auth Service
[Implementation details...]

## Phase 3: Security Hardening
[Security measures...]

Would you like me to proceed with implementation?
```

### Refactoring Planning

```
You: "think: Plan how to refactor this 500-line component"

<thinking>
Analyzing component structure...

Current issues:
- Single component handling too many concerns
- Mixed business logic and presentation
- No separation of data fetching
- Hard to test

Refactoring strategy:
1. Extract data fetching to custom hook
2. Separate presentational components
3. Move business logic to utility functions
4. Create composable sub-components
5. Add TypeScript types

Component hierarchy:
- UserDashboard (container)
  - UserProfile (presentation)
  - UserStats (presentation)
  - UserActivity (presentation)
  - useUserData (hook)

Benefits:
- Easier testing
- Better reusability
- Clearer separation of concerns
- Improved performance (React.memo opportunities)
</thinking>

Claude: Refactoring plan for UserDashboard:

## Step 1: Extract Custom Hook
[Code example...]

## Step 2: Create Sub-Components
[Code example...]

This refactoring will improve maintainability and performance.
Proceed with implementation?
```

## Best Practices

### Choose the Right Mode

**Start with lower modes**:

```
1. Try standard mode first
2. If result is incomplete → use think
3. If problem is complex → use think hard
4. If critical → use think harder/ultrathink
```

### Be Specific About What to Think About

❌ **Vague**:
```
think: Fix this
```

✅ **Specific**:
```
think: Analyze why this query is slow and propose optimizations considering:
- Index usage
- Query structure
- N+1 problems
- Caching opportunities
```

### Combine with Clear Requirements

```
think hard: Design a caching strategy

Requirements:
- 100K requests per second
- 99.9% uptime
- Sub-100ms latency
- Multi-region deployment
- Cache invalidation on updates

Consider Redis, CDN, and application-level caching.
```

### Review Thinking Process

Read the `<thinking>` sections:

```
<thinking>
Three approaches:
1. Client-side caching (pros/cons)
2. CDN caching (pros/cons)
3. Redis caching (pros/cons)

Best approach: Multi-layer caching combining all three
</thinking>
```

Claude shows its reasoning - verify it makes sense.

### Use for Learning

Extended thinking explains concepts:

```
You: "think: Explain how React's reconciliation algorithm works"

<thinking>
Reconciliation is React's process for updating the DOM efficiently.
Let me break down the key concepts:
1. Virtual DOM representation
2. Diffing algorithm
3. Fiber architecture
4. Reconciliation phases
...
</thinking>

Claude: [Detailed explanation with examples]
```

## Performance Impact

### Response Time

| Mode | Typical Response Time |
|------|----------------------|
| Standard | 2-5 seconds |
| Think | 5-10 seconds |
| Think Hard | 10-20 seconds |
| Think Harder | 20-40 seconds |
| Ultrathink | 40-120 seconds |

**Trade-off**: Wait longer for better results.

### Cost Impact

Thinking tokens are **cheaper** than output tokens:

- **Thinking tokens**: Lower cost (internal reasoning)
- **Output tokens**: Higher cost (final response)

Extended thinking can actually **reduce** overall cost by:
- Avoiding mistakes that require multiple iterations
- Producing better code that doesn't need rework
- Planning efficiently to prevent wasted effort

### When Speed Matters

Use standard mode for:
- Interactive development
- Quick iterations
- Simple edits
- Time-sensitive tasks

Use extended thinking for:
- Critical decisions
- Complex problems
- First-time implementations
- High-stakes changes

## Real-World Examples

### Example 1: Database Migration

```
You: "think harder: Plan our migration from MySQL to PostgreSQL"

<thinking>
This is a critical migration requiring careful planning.

Assessment:
- Database size: 500GB
- Tables: 150+
- Daily writes: 10M rows
- Downtime tolerance: 4 hours max

Migration strategies:
1. Big bang (risky, simple)
2. Phased migration (safer, complex)
3. Dual-write approach (safest, most complex)

Recommendation: Dual-write approach

Phases:
1. Setup PostgreSQL infrastructure
2. Implement dual-write logic
3. Backfill historical data
4. Validate data consistency
5. Switch reads to PostgreSQL
6. Remove MySQL writes
7. Decommission MySQL

Risks and mitigations:
- Data inconsistency → automated reconciliation
- Performance degradation → thorough load testing
- Application bugs → feature flags
- Rollback complexity → maintain MySQL as fallback

Timeline: 8-12 weeks
</thinking>

Claude: PostgreSQL Migration Plan

## Phase 1: Infrastructure (Week 1-2)
[Detailed steps...]

## Phase 2: Dual-Write Implementation (Week 3-4)
[Detailed steps...]

[Complete migration plan continues...]
```

### Example 2: Performance Optimization

```
You: "think hard: This API endpoint is timing out. Analyze and fix."

<thinking>
Analyzing endpoint performance...

Current implementation review:
- Fetches user data
- Loads all user posts
- Populates post authors
- Calculates statistics
- Returns full dataset

Problems identified:
1. N+1 query problem (posts → authors)
2. Loading all posts (should paginate)
3. Computing stats on every request (should cache)
4. No database indexes
5. Sending unnecessary data

Solutions ranked by impact:
1. Add database indexes (biggest impact)
2. Fix N+1 with JOIN
3. Add pagination
4. Cache computed statistics
5. Use GraphQL for selective fields

Implementation plan...
</thinking>

Claude: Performance Optimization Plan

## Issue: N+1 Query Problem

Current (slow):
```typescript
const posts = await db.posts.findMany({ userId });
for (const post of posts) {
  post.author = await db.users.findUnique({ id: post.authorId });
}
```

Fixed (fast):
```typescript
const posts = await db.posts.findMany({
  where: { userId },
  include: { author: true },
  take: 20, // Pagination
  skip: offset
});
```

[Complete optimization plan...]
```

## Troubleshooting

### Not Seeing Thinking Process

Enable thinking visibility:

```bash
claude --show-thinking
```

Or in conversation:

```
/settings show-thinking true
```

### Thinking Mode Not Working

Verify syntax:

```
# Correct
think: Your question

# Incorrect
/think Your question  # Wrong - not a slash command
```

### Too Slow

If ultrathink is too slow:

```
# Use faster mode
think hard: [same question]

# Or standard mode with detailed prompt
[Detailed question without think prefix]
```

### Overthinking Simple Tasks

Don't use extended thinking for simple tasks:

❌ **Overkill**:
```
think harder: Add a console.log statement
```

✅ **Appropriate**:
```
Add a console.log statement
```

## Next Steps

- [Best Practices](/docs/claude-code-best-practices) - When to use thinking modes
- [Configuration](/docs/claude-code-configuration) - Set default thinking mode
- [Multi-Agent](/docs/claude-code-multi-agent) - Use thinking in parallel workflows

## Resources

- **Thinking Modes Guide**: Detailed usage patterns
- **Performance Comparison**: Benchmarks for each mode
- **Case Studies**: Real-world applications

---

*Extended thinking transforms Claude from a code assistant to a thoughtful development partner that carefully analyzes problems before proposing solutions.*
