---
title: "Architecture"
description: "Engineered for reusability and community, it uses a unified, feature-based pattern, keeping every component independent and discoverable."
---

**From radix, shadcn, atoms, templates, blocks, micros — to full masterpiece.**

Our architecture is engineered from the ground up for reusability, modularity, and a world-class developer experience. It's not just a system for building applications; it's a framework for composing "atomic" automation components into a powerful, collaborative, and AI-augmented ecosystem. We prioritize a scalable, feature-based structure to ensure that every contribution adds lasting, discoverable value to the entire codebase.

## Core Architecture Principles

1. **Component-Driven Modularity** – Inspired by shadcn/ui philosophy, providing reusable, customizable components at their most minimal, essential state
2. **Superior Developer Experience** – Intuitive and predictable structure for productivity
3. **Feature-Based & Composable** – Micro-services and micro-frontends approach with independent components
4. **Serverless-First** – Deploy on Vercel with Neon Postgres for serverless DB
5. **Type-Safety by Default** – Prisma + Zod + TypeScript across the stack
6. **Async-First** – Small PRs, documented decisions, steady progress

## Composition Hierarchy

- **Foundation Layer**: Radix UI → shadcn/ui → shadcn Ecosystem
- **Building Blocks**: UI → Atoms → Templates → Blocks → Micro → Apps

## Mirror-Pattern

Every URL route produces **two directories**: one in `app/` for routing and layouts, one in `components/` for all feature logic. This 1:1 mapping means if you know the URL, you instantly know where to find both the page and its components.

For example, the route `/abc` creates:

- `app/[lang]/abc/` — `page.tsx`, `layout.tsx`
- `components/abc/` — `content.tsx`, `actions.ts`, `form.tsx`, `validation.ts`, `types.ts`, `use-abc.ts`, `README.md`, `ISSUE.md`, etc.

This predictable structure eliminates guesswork. New features follow the same pattern. Refactoring is straightforward. AI tools understand it instantly.

<Structure />

## Tech Stack

- **Framework**: Next.js 16.1.0 with App Router and Turbopack, React 19.2.0, TypeScript 5.8.3
- **Database**: PostgreSQL with Prisma ORM 6.19.0 (264 models, 132 enums), Neon Serverless
- **Authentication**: NextAuth v5 (beta.30) with custom multi-tenant Prisma adapter
- **Styling**: Tailwind CSS v4 with OKLCH color format
- **UI Components**: Radix UI primitives + shadcn/ui (35 component directories)
- **Validation**: Zod 4.0.14 schemas with React Hook Form 7.61.1
- **Internationalization**: Arabic (RTL) + English (LTR) with on-demand translation
- **Documentation**: MDX with Fumadocs
- **Runtime Strategy**: Node.js for Prisma/bcrypt pages, Edge for middleware/static
- **Storage**: AWS S3 + CloudFront CDN for images, Upstash Redis for custom domains

## Standardized File Patterns

Each feature directory follows these naming conventions:

| File            | Purpose                                                           |
| --------------- | ----------------------------------------------------------------- |
| `content.tsx`   | Compose feature/page UI: headings, sections, layout orchestration |
| `actions.ts`    | Server actions & API calls: validate, scope tenant, mutate        |
| `config.ts`     | Enums, option lists, labels, defaults for the feature             |
| `validation.ts` | Zod schemas & refinements; parse and infer types                  |
| `types.ts`      | Domain and UI types; generic helpers for forms/tables             |
| `form.tsx`      | Typed forms (RHF) with resolvers and submit handling              |
| `card.tsx`      | Card components for KPIs, summaries, quick actions                |
| `all.tsx`       | List view with table, filters, pagination                         |
| `featured.tsx`  | Curated feature list showcasing selections                        |
| `detail.tsx`    | Detail view with sections, relations, actions                     |
| `util.ts`       | Pure utilities and mappers used in the feature                    |
| `column.tsx`    | Typed Table column builders and cell renderers                    |
| `use-abc.ts`    | Feature hooks: fetching, mutations, derived state                 |
| `README.md`     | Feature README: purpose, APIs, decisions                          |
| `ISSUE.md`      | Known issues and follow-ups for the feature                       |

## Decision Framework

1. **Mirror-Pattern First**: Every new route in `app/[lang]/` must have a mirrored directory in `components/`
2. **Component Reusability**: Start with shadcn/ui components, extend only when necessary
3. **File Pattern Adherence**: Use standardized file names (content.tsx, action.ts, etc.)
4. **Type-Safety Chain**: Zod schemas → TypeScript types → Prisma models
5. **Serverless Compatibility**: Default to Edge runtime unless Prisma/bcrypt required
6. **Feature Isolation**: Each feature should be independently deployable and testable
7. **Progressive Enhancement**: UI → Atoms → Templates → Blocks → Micro → Apps
8. **Developer Experience**: Predictable structure, clear naming, documented decisions

## Naming Conventions

- **Components**: kebab-case for files (`button.tsx`, `user-profile.tsx`)
- **Pages**: kebab-case for route segments (`user-profile`, `sign-in`)
- **Hooks**: use-prefix convention (`use-leads.ts`, `use-upwork.ts`)
- **Types**: PascalCase for interfaces and types
- **Constants**: UPPER_SNAKE_CASE or camelCase for objects

## Critical Files Reference

| File                          | Lines    | Purpose                                                                   |
| ----------------------------- | -------- | ------------------------------------------------------------------------- |
| `src/proxy.ts`                | 388      | Edge middleware: subdomain detection, RBAC, URL rewriting, custom domains |
| `src/auth.ts`                 | 777      | NextAuth: JWT callbacks, session management, redirect logic               |
| `src/auth.config.ts`          | 151      | OAuth providers: Google, Facebook, Credentials                            |
| `src/routes.ts`               | 410      | RBAC matrix: role-based route protection                                  |
| `src/lib/rate-limit.ts`       | 537      | Rate limiting: 14 configs across routes                                   |
| `src/lib/tenant-context.ts`   | 189      | Tenant resolution with caching                                            |
| `src/lib/catalog-setup.ts`    | 366      | Catalog bridge: academic structure provisioning                           |
| `src/lib/dns-service.ts`      | 644      | DNS verification: multi-provider custom domains                           |
| `src/lib/security-headers.ts` | 173      | CSP, HSTS, XSS protection                                                 |
| `prisma/models/`              | 57 files | 264 models, 132 enums                                                     |
| `CLAUDE.md`                   | —        | Project-wide architectural guidelines                                     |

## Anti-Pattern Detection

Watch out for these common mistakes:

- Components not following mirror-pattern structure
- Monolithic components that should be decomposed
- Missing type-safety chain (Zod validations, TypeScript types)
- Files not following standardized naming conventions
- Features with tight coupling preventing independent deployment
- Hardcoded values instead of using `config.ts`
- Direct database queries instead of using `actions.ts` patterns

## A Typical Interaction

1. A user interacts with a component from `form.tsx` on the Next.js frontend, triggering a Server Action from `actions.ts`
2. The request payload is validated by a Zod schema from `validation.ts`
3. The serverless function uses the type-safe Prisma client to query Neon, using interfaces from `types.ts`
4. The result is **streamed** back and managed by a hook from `use-abc.ts`, efficiently updating the UI
