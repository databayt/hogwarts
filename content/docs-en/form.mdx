---
title: "Form"
description: "Canonical patterns for writing form.tsx client components in feature directories"
---

## Current Progress (Audit)

59 form.tsx files audited across the codebase (~15,703 total lines):

| Area                                   | Status | Detail                                                                                   |
| -------------------------------------- | ------ | ---------------------------------------------------------------------------------------- |
| `"use client"` directive               | PASS   | All 59 files include the directive                                                       |
| react-hook-form + zodResolver          | PASS   | 76% use react-hook-form with zodResolver                                                 |
| Schema imported from validation.ts     | PASS   | 74% import schemas from co-located validation.ts                                         |
| Named exports only                     | PASS   | 100% use named exports (`export function`)                                               |
| `useForm<z.infer<typeof schema>>()`    | PASS   | Consistent generic typing across react-hook-form usages                                  |
| `zodResolver(schema) as any` type cast | FAIL   | 10+ files cast zodResolver to `any`, hiding type mismatches                              |
| Inline schema definitions              | FAIL   | 15 files define Zod schemas inline instead of importing from validation.ts               |
| `dictionary: any` type usage           | FAIL   | 28 files type dictionary prop as `any`                                                   |
| 829-line sales/form.tsx monolith       | FAIL   | Largest form file; mixes CRUD, search, analytics, and export concerns                    |
| onboarding/form.tsx packs 6 components | FAIL   | 666 lines with 6 sub-components that should be separate files                            |
| Mixed form + non-form concerns         | FAIL   | Several files include data fetching, table rendering, or utility logic alongside form UI |

## 6 Categories of form.tsx

### Category 1: CRUD Modal Forms (~16 files)

Create/edit/view entity via modal dialog. Uses `useModal()` context for mode detection (`modal.id` prefix `"view:"` for read-only). Typically 130-250 lines.

Reference: `listings/subjects/form.tsx` (165 lines), `listings/grades/form.tsx` (194 lines)

### Category 2: Wizard Step Forms (~6 files)

One step in a multi-step wizard. Uses `forwardRef` + `useImperativeHandle` to expose `saveAndNext()` to parent orchestrator. Typically 200-400 lines.

Reference: `apply/personal/form.tsx` (330 lines), `apply/contact/form.tsx`

### Category 3: Onboarding Step Forms (~11 files)

Similar to wizard step forms but specifically for school onboarding. Each file handles one onboarding step (branding, curriculum, pricing, etc.).

Reference: `onboarding/description/form.tsx`, `onboarding/branding/form.tsx`

### Category 4: Auth Forms (~5 files)

Login, register, reset password, 2FA. Operate before tenant context is available. Use i18n schema factories.

Reference: `auth/login/form.tsx`, `auth/register/form.tsx`

### Category 5: Settings/Config Forms (~9 files)

Update existing configuration or preferences. Load current values on mount, save on submit. No modal -- inline or page-level forms.

Reference: `timetable/settings/form.tsx`, `school-dashboard/settings/form.tsx`

### Category 6: Exam/Stream Forms (~10 files)

Assessment creation, question editing, enrollment. Often include dynamic field arrays for questions/options.

Reference: `exams/qbank/form.tsx`, `stream/courses/enrollment/form.tsx`

## The 6 Rules

### 1. Always `"use client"` at the top

Every form.tsx is a client component. Forms require browser APIs (event handlers, state, refs).

```typescript
"use client"

import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"

// ...
```

### 2. Always import schema from validation.ts

Never define Zod schemas inline in form.tsx. The validation.ts file is the single source of truth.

```typescript
// GOOD: Schema from validation.ts
import { subjectCreateSchema } from "./validation"

const form = useForm<z.infer<typeof subjectCreateSchema>>({
  resolver: zodResolver(subjectCreateSchema),
})

// BAD: Inline schema in form.tsx (15 files do this)
const schema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
})
```

### 3. Always use zodResolver with proper typing

Use `zodResolver(schema)` with `z.infer<typeof schema>` as the generic. Never cast to `any`.

```typescript
// GOOD: Properly typed
const form = useForm<z.infer<typeof subjectCreateSchema>>({
  resolver: zodResolver(subjectCreateSchema),
  defaultValues: {
    subjectName: "",
    departmentId: "",
  },
})

// BAD: Cast to any (10+ files do this)
const form = useForm({
  resolver: zodResolver(schema) as any,
})
```

### 4. Use `<Name>Input` type from validation.ts

Import the inferred type for form values rather than re-inferring inline.

```typescript
// GOOD: Import type from validation.ts
import { personalSchema, type PersonalInput } from "./validation"

const form = useForm<PersonalInput>({
  resolver: zodResolver(personalSchema),
})

// ALSO GOOD: Inline infer (acceptable when type not exported)
const form = useForm<z.infer<typeof personalSchema>>({
  resolver: zodResolver(personalSchema),
})
```

### 5. Max ~200 lines -- extract sub-steps to separate files

Forms over 200 lines indicate mixed concerns. Extract step components, field groups, or helper functions.

```
# BAD: onboarding/form.tsx (666 lines, 6 components)

# GOOD: Split by step
onboarding/
  form.tsx              # Orchestrator (~100 lines)
  steps/
    description.tsx     # Step 1 fields
    branding.tsx        # Step 2 fields
    curriculum.tsx      # Step 3 fields
    pricing.tsx         # Step 4 fields
```

### 6. Call server actions via onSubmit, not inline

Submit handlers call server actions and handle the response. Keep the action call in a dedicated `onSubmit` function.

```typescript
// GOOD: Dedicated onSubmit handler
async function onSubmit(values: z.infer<typeof subjectCreateSchema>) {
  try {
    const res = currentId
      ? await updateSubject({ id: currentId, ...values })
      : await createSubject(values)
    if (res?.success) {
      toast.success(currentId ? "Subject updated" : "Subject created")
      closeModal()
      onSuccess?.()
    } else {
      toast.error(res?.error || "Failed to save")
    }
  } catch (error) {
    console.error("Form submission error:", error)
    toast.error("An unexpected error occurred")
  }
}

// BAD: Inline action call in JSX
<form onSubmit={form.handleSubmit(async (v) => {
  const res = await createSubject(v) // messy inline
  // ...
})}>
```

## 3 Canonical Templates

### Template A: CRUD Modal Form

Full create/edit/view form in a modal. Uses `useModal()` for mode, loads existing data in `useEffect`. Reference: `listings/subjects/form.tsx` (165 lines).

```typescript
"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { Form } from "@/components/ui/form"
import { useModal } from "@/components/atom/modal/context"
import { ModalFooter } from "@/components/atom/modal/modal-footer"
import { ModalFormLayout } from "@/components/atom/modal/modal-form-layout"

import { createSubject, getSubject, updateSubject } from "./actions"
import { subjectCreateSchema } from "./validation"

import { InformationStep } from "./information"

interface SubjectCreateFormProps {
  onSuccess?: () => void
}

export function SubjectCreateForm({ onSuccess }: SubjectCreateFormProps) {
  const { modal, closeModal } = useModal()
  const router = useRouter()
  const [currentStep, setCurrentStep] = useState(1)
  const form = useForm<z.infer<typeof subjectCreateSchema>>({
    resolver: zodResolver(subjectCreateSchema),
    defaultValues: {
      subjectName: "",
      departmentId: "",
    },
  })

  const isView = !!(modal.id && modal.id.startsWith("view:"))
  const currentId = modal.id
    ? modal.id.startsWith("view:")
      ? modal.id.split(":")[1]
      : modal.id
    : undefined

  // Load existing data for edit/view
  useEffect(() => {
    const load = async () => {
      if (!currentId) return
      const res = await getSubject({ id: currentId })
      if (!res.success || !res.data) return
      const s = res.data as any
      form.reset({
        subjectName: s.subjectName ?? "",
        departmentId: s.departmentId ?? "",
      })
    }
    void load()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentId])

  async function onSubmit(values: z.infer<typeof subjectCreateSchema>) {
    try {
      const res = currentId
        ? await updateSubject({ id: currentId, ...values })
        : await createSubject(values)
      if (res?.success) {
        toast.success(currentId ? "Subject updated" : "Subject created")
        closeModal()
        if (onSuccess) {
          onSuccess()
        } else {
          router.refresh()
        }
      } else {
        toast.error(res?.error || "Failed to save")
      }
    } catch (error) {
      console.error("Form submission error:", error)
      toast.error("An unexpected error occurred")
    }
  }

  const handleNext = async () => {
    const step1Valid = await form.trigger(["subjectName", "departmentId"])
    if (step1Valid) {
      await form.handleSubmit(onSubmit)()
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={(e) => e.preventDefault()}>
        <ModalFormLayout
          title={isView ? "View Subject" : currentId ? "Edit Subject" : "Create Subject"}
          description={isView ? "View details" : currentId ? "Update details" : "Add new"}
        >
          <InformationStep form={form} isView={isView} />
        </ModalFormLayout>
        <ModalFooter
          currentStep={currentStep}
          totalSteps={1}
          stepLabel="Subject Details"
          isView={isView}
          isEdit={!!currentId}
          isDirty={form.formState.isDirty}
          onBack={() => closeModal()}
          onNext={handleNext}
          onSaveStep={handleNext}
        />
      </form>
    </Form>
  )
}
```

Key points:

- `useModal()` provides create/edit/view mode via `modal.id` prefix
- `useEffect` loads existing data for edit/view modes
- `onSuccess` callback for optimistic UI refresh, fallback to `router.refresh()`
- `form.trigger()` validates specific fields per step before submitting
- `ModalFormLayout` + `ModalFooter` for consistent modal structure

### Template B: Wizard Step Form with forwardRef

One step in a multi-step wizard. Parent controls navigation via ref. Reference: `apply/personal/form.tsx` (330 lines).

```typescript
"use client"

import React, { forwardRef, useEffect, useImperativeHandle } from "react"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"

import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"

import { useApplySession } from "../application-context"
import { savePersonalStep } from "./actions"
import { GENDER_OPTIONS, NATIONALITY_OPTIONS } from "./config"
import type { PersonalFormProps, PersonalFormRef } from "./types"
import { personalSchema, type PersonalInput } from "./validation"

export const PersonalForm = forwardRef<PersonalFormRef, PersonalFormProps>(
  ({ initialData, onSuccess, dictionary }, ref) => {
    const { session, updateStepData } = useApplySession()

    const form = useForm<PersonalInput>({
      resolver: zodResolver(personalSchema),
      defaultValues: {
        firstName: initialData?.firstName || "",
        lastName: initialData?.lastName || "",
        dateOfBirth: initialData?.dateOfBirth || "",
        gender: initialData?.gender || undefined,
        nationality: initialData?.nationality || "",
      },
    })

    // Sync form values to shared context
    useEffect(() => {
      const subscription = form.watch((value) => {
        updateStepData("personal", value as PersonalInput)
      })
      return () => subscription.unsubscribe()
    }, [form, updateStepData])

    const saveAndNext = async () => {
      const isValid = await form.trigger()
      if (!isValid) throw new Error("Form validation failed")

      const data = form.getValues()
      const result = await savePersonalStep(data)
      if (!result.success) throw new Error(result.error || "Failed to save")

      if (result.data) updateStepData("personal", result.data)
      onSuccess?.()
    }

    // Expose saveAndNext to parent via ref
    useImperativeHandle(ref, () => ({ saveAndNext }))

    return (
      <Form {...form}>
        <form className="space-y-4">
          <FormField
            control={form.control}
            name="firstName"
            render={({ field }) => (
              <FormItem>
                <FormLabel>First Name</FormLabel>
                <FormControl>
                  <Input {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          {/* ... additional fields */}
        </form>
      </Form>
    )
  }
)
```

Key points:

- `forwardRef` + `useImperativeHandle` expose `saveAndNext()` to the parent orchestrator
- `form.watch()` syncs values to shared context (`useApplySession`)
- Client validation via `form.trigger()`, then server validation via action
- Props and ref types imported from `./types`
- Schema imported from `./validation`

### Template C: Multi-Step Modal Form

Two or more steps within a single modal. Per-step field validation via `form.trigger()`. Reference: `listings/grades/form.tsx` (194 lines).

```typescript
"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import { toast } from "sonner"
import { z } from "zod"

import { Form } from "@/components/ui/form"
import { useModal } from "@/components/atom/modal/context"
import { ModalFooter } from "@/components/atom/modal/modal-footer"
import { ModalFormLayout } from "@/components/atom/modal/modal-form-layout"
import type { Dictionary } from "@/components/internationalization/dictionaries"

import { createResult, getResult, updateResult } from "./actions"
import { resultCreateSchema } from "./validation"

import { GradingStep } from "./grading"
import { StudentAssignmentStep } from "./student-assignment"

interface ResultCreateFormProps {
  dictionary: Dictionary["school"]["grades"]
  onSuccess?: () => void
}

export function ResultCreateForm({ dictionary, onSuccess }: ResultCreateFormProps) {
  const { modal, closeModal } = useModal()
  const router = useRouter()
  const [currentStep, setCurrentStep] = useState(1)
  const t = dictionary
  const form = useForm<z.infer<typeof resultCreateSchema>>({
    resolver: zodResolver(resultCreateSchema),
    defaultValues: {
      studentId: "",
      assignmentId: "",
      classId: "",
      score: 0,
      maxScore: 0,
      grade: "",
      feedback: "",
    },
  })

  const isView = !!(modal.id && modal.id.startsWith("view:"))
  const currentId = modal.id
    ? modal.id.startsWith("view:") ? modal.id.split(":")[1] : modal.id
    : undefined

  useEffect(() => {
    const load = async () => {
      if (!currentId) return
      const res = await getResult({ id: currentId })
      if (!res.success || !res.data) return
      form.reset({ ...res.data })
    }
    void load()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentId])

  async function onSubmit(values: z.infer<typeof resultCreateSchema>) {
    const res = currentId
      ? await updateResult({ id: currentId, ...values })
      : await createResult(values)
    if (res?.success) {
      toast.success(currentId ? t.resultUpdated : t.resultCreated)
      closeModal()
      onSuccess ? onSuccess() : router.refresh()
    } else {
      toast.error(currentId ? t.failedToUpdate : t.failedToCreate)
    }
  }

  const handleNext = async () => {
    if (currentStep === 1) {
      // Validate step 1 fields only
      const step1Valid = await form.trigger(["studentId", "assignmentId", "classId"])
      if (step1Valid) setCurrentStep(2)
    } else {
      await form.handleSubmit(onSubmit)()
    }
  }

  const renderCurrentStep = () => {
    switch (currentStep) {
      case 1:
        return <StudentAssignmentStep form={form} isView={isView} />
      case 2:
        return <GradingStep form={form} isView={isView} />
      default:
        return null
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={(e) => e.preventDefault()}>
        <ModalFormLayout title={isView ? "View" : currentId ? "Edit" : "Create"}>
          {renderCurrentStep()}
        </ModalFormLayout>
        <ModalFooter
          currentStep={currentStep}
          totalSteps={2}
          isView={isView}
          isEdit={!!currentId}
          isDirty={form.formState.isDirty}
          onBack={() => currentStep > 1 ? setCurrentStep(currentStep - 1) : closeModal()}
          onNext={handleNext}
        />
      </form>
    </Form>
  )
}
```

Key points:

- `currentStep` state controls which step renders
- `form.trigger(["field1", "field2"])` validates only the current step's fields
- Step components (`StudentAssignmentStep`, `GradingStep`) receive `form` and `isView` props
- Final step calls `form.handleSubmit(onSubmit)()`
- Dictionary-based i18n for toast messages

## Anti-Patterns

### 1. `zodResolver(schema) as any` (10+ files)

Casting zodResolver to `any` hides type mismatches between the schema and form values.

```typescript
// BAD: Type cast hides mismatches
resolver: zodResolver(schema) as any

// GOOD: Fix the type mismatch at the source
resolver: zodResolver(subjectCreateSchema)
// If types don't match, fix the schema or defaultValues
```

### 2. Inline schema definitions (15 files)

Schemas defined directly in form.tsx instead of imported from validation.ts.

```typescript
// GOOD: Import from validation.ts
import { itemSchema } from "./validation"

// BAD: Schema in form.tsx
const schema = z.object({ name: z.string().min(1) })
const form = useForm({ resolver: zodResolver(schema) })

const form = useForm({ resolver: zodResolver(itemSchema) })
```

### 3. `dictionary: any` (28 files)

Dictionary prop typed as `any` instead of the proper Dictionary type.

```typescript
// BAD: any type
function MyForm({ dictionary }: { dictionary: any }) { ... }

// GOOD: Proper typing
import type { Dictionary } from "@/components/internationalization/dictionaries"
function MyForm({ dictionary }: { dictionary: Dictionary["school"]["grades"] }) { ... }
```

### 4. 829-line sales/form.tsx monolith

Mixes CRUD form, search, analytics views, and export logic in a single file.

```
# BAD: sales/form.tsx (829 lines, mixed concerns)

# GOOD: Split by concern
sales/
  form.tsx         # CRUD form (~200 lines)
  search.tsx       # Search/filter UI
  analytics.tsx    # Analytics views
  export.tsx       # Export functionality
```

### 5. Mixing form + non-form concerns

Some form files include data fetching, table rendering, or utility functions that belong in other files.

```typescript
// BAD: Data fetching in form.tsx
export function MyForm() {
  const [data, setData] = useState([])
  useEffect(() => {
    fetch("/api/items")
      .then((res) => res.json())
      .then(setData)
  }, [])
  // ... renders both a form AND a data table
}

// GOOD: Form only -- data comes via props or context
export function MyForm({ items }: { items: Item[] }) {
  // ... renders form only
}
```

## Quick Reference

### Form Setup Pattern

```typescript
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"

import { mySchema, type MyInput } from "./validation"

const form = useForm<MyInput>({
  resolver: zodResolver(mySchema),
  defaultValues: {
    /* ... */
  },
})
```

### Import Direction

```
config.ts     (options, limits)
    |
validation.ts (schemas, types)
    |
+---+---+
|       |
form  actions
.tsx    .ts
```

Form imports FROM validation.ts (schemas, types) and config.ts (option arrays). Actions.ts also imports from validation.ts.

### Co-located File Structure

```
src/components/<feature>/
  config.ts         # Option arrays, limits
  validation.ts     # Zod schemas + inferred types
  actions.ts        # Server actions (form.tsx calls these)
  types.ts          # Props, ref types for form
  form.tsx          # Client component (this file)
  information.tsx   # Step sub-component (extracted from form)
  content.tsx       # Server component (renders form)
```

### What Belongs Where

| Content                         | Belongs in      | Not in      |
| ------------------------------- | --------------- | ----------- |
| `useForm()` setup               | `form.tsx`      | content.tsx |
| `zodResolver(schema)`           | `form.tsx`      | actions.ts  |
| Zod schema definition           | `validation.ts` | form.tsx    |
| Server action call              | `form.tsx`      | content.tsx |
| Option arrays for selects       | `config.ts`     | form.tsx    |
| Form ref/props types            | `types.ts`      | form.tsx    |
| Step sub-components (>50 lines) | Separate file   | form.tsx    |
