---
title: "Vibe Coding"
description: "Documentation for Vibe Coding"
---

# Vibe Coding

Welcome to the **Vibe Coding** documentation. This section covers the modern approach to software development using AI-powered code generation and conversational programming.

## What is Vibe Coding?

**Vibe Coding** refers to a software development approach where developers use large language models (LLMs) to generate code based on natural language prompts. It's characterized by a more relaxed and conversational style, where developers provide high-level directions and the AI handles the low-level implementation details.

Key characteristics of vibe coding:

- **Natural Language Prompts**: Describe what you want in plain English
- **AI-Generated Code**: Let LLMs handle the precise coding details
- **Conversational Development**: Iterate through dialogue with AI assistants
- **High-Level Direction**: Focus on the "what" rather than the "how"
- **Rapid Prototyping**: Quickly generate working code from ideas

## Core Principles

### 1. Prompt Engineering
Master the art of communicating with AI:
- Be specific about requirements and constraints
- Provide context about your tech stack and preferences
- Use clear, unambiguous language
- Break complex tasks into smaller, manageable prompts

### 2. Iterative Refinement
Develop through conversation:
- Start with a basic implementation
- Refine through follow-up prompts
- Ask for specific improvements or modifications
- Build complexity gradually

### 3. AI as a Coding Partner
Leverage AI effectively:
- Use AI for boilerplate code generation
- Get help with complex algorithms and logic
- Generate documentation and comments
- Explore different implementation approaches

### 4. Human Oversight
Maintain quality and control:
- Review and understand generated code
- Test thoroughly before deployment
- Validate security and performance implications
- Maintain architectural consistency

## Getting Started with Vibe Coding

### 1. Choose Your AI Tool
Popular tools used by the vibe coding community:

**Primary AI Assistants:**
- **[Claude.ai](https://claude.ai/new)**: Advanced reasoning and code generation
- **[ChatGPT](https://chatgpt.com/)**: Versatile AI assistant for coding
- **[DeepSeek Chat](https://chat.deepseek.com/)**: Specialized coding AI
- **[Poe](https://poe.com/)**: Access to multiple AI models
- **[v0.dev](https://v0.dev/chat)**: AI-powered UI component generation

**Integrated Development Tools:**
- **[Cursor IDE](https://www.cursor.com/)**: AI-first code editor
- **[GitHub Copilot](https://github.com/features/copilot)**: AI pair programmer

### 2. Learn Effective Prompting
```
// Instead of: "Make a function"
// Try: "Create a TypeScript function that validates email addresses using regex, returns boolean, and handles edge cases like empty strings"
```

### 3. Start Small
Begin with simple tasks:
- Generate utility functions
- Create basic components
- Write test cases
- Generate configuration files

### 4. Build Complexity
Progress to larger tasks:
- Implement full features
- Create API endpoints
- Build complete components
- Generate entire modules

## Best Practices

### Effective Prompting
- **Be Specific**: Include exact requirements, tech stack, and coding standards
- **Provide Context**: Share relevant existing code or architecture
- **Set Constraints**: Mention performance, security, or style requirements
- **Ask for Explanations**: Request comments or documentation alongside code

### Code Quality
- **Always Review**: Never blindly accept generated code
- **Test Thoroughly**: AI-generated code needs comprehensive testing
- **Refactor When Needed**: Clean up and optimize generated code
- **Maintain Standards**: Ensure consistency with your project's patterns

### Security Considerations
- **Validate Inputs**: AI might not always consider security implications
- **Review Dependencies**: Check any suggested libraries or packages
- **Audit Sensitive Code**: Extra scrutiny for authentication, data handling, etc.
- **Test Edge Cases**: AI might miss unusual scenarios

## Advanced Techniques

### Multi-Turn Conversations
Build complex features through dialogue:
```
1. "Create a React component for user authentication"
2. "Add form validation to the login component"
3. "Implement password strength indicator"
4. "Add social login options"
```

### Test-Driven Development Workflow
A proven pattern used by the vibe coding community:
```
1. "Write tests first, then the code, then run the tests and update the code until tests pass"
2. "I have got some build errors, run 'nr build' to see the errors, and then fix them"
3. "Run build until build passes"
```

### Cursor AI Optimization Hack
**Save Requests and Money with the 10x Tool Calls Technique:**

When using Cursor AI's paid plan ($20/month with 500 requests), every message counts as a full request, even simple ones like "Hello". This can drain your quota quickly.

**Solution: Use the `userinput.py` script**
- From the open-source [10x Tool Calls](https://github.com/perrypixel/10x-Tool-Calls/) project
- Creates an interactive terminal-like interface
- Each command within the interface counts as a Tool Call within the same request
- Build entire projects step-by-step while using only one request
- Up to 25 Tool Calls per request limit

**Setup:**
1. Add the `userinput.py` script to your project
2. Configure according to the setup guide
3. Use the interactive interface for all AI interactions
4. Complete multiple development steps within a single request

### Code Explanation and Learning
Use AI to understand existing code:
- "Explain what this function does"
- "How can I optimize this algorithm?"
- "What are potential issues with this implementation?"

### Debugging Assistance
Get help with troubleshooting:
- "Why isn't this function working as expected?"
- "Help me fix this error message"
- "Suggest improvements for better performance"

## Tools and Resources

### Community Recommended AI Tools
Based on the awesome vibe Discord community recommendations:

**Primary AI Assistants:**
- **[Claude.ai](https://claude.ai/new)**: Advanced reasoning and code generation
- **[ChatGPT](https://chatgpt.com/)**: Versatile AI assistant for coding
- **[DeepSeek Chat](https://chat.deepseek.com/)**: Specialized coding AI
- **[Poe](https://poe.com/)**: Access to multiple AI models
- **[v0.dev](https://v0.dev/chat)**: AI-powered UI component generation

**Development Tools:**
- **[Cursor IDE](https://www.cursor.com/)**: AI-first code editor
- **[GitHub Copilot](https://github.com/features/copilot)**: AI pair programmer

### Learning Resources
- **[Vibe Coding Tutorial by Matthew Berman](https://www.youtube.com/watch?v=v7UcVPO4y3c)**: Setup and advanced tips and tricks
- **[10x Tool Calls Project](https://github.com/perrypixel/10x-Tool-Calls/)**: Optimization tools for Cursor AI

### Community Best Practices
- **Next.js Best Practices**: Adapt globs depending on your project's specific structure and file types
- **Test-Driven Development**: Write tests first, then code, then iterate until tests pass
- **Build Error Resolution**: Run build commands to identify and fix errors systematically

### Prompt Engineering
- Learn effective prompt patterns
- Study successful examples from the community
- Practice iterative refinement
- Understand model limitations
- Use specific, detailed prompts for better results

### Integration
- Set up AI tools in your existing workflow
- Configure preferences and settings
- Learn keyboard shortcuts and commands
- Integrate with version control
- Implement cost-saving optimization techniques

## Common Patterns

### Component Generation
```
"Create a reusable Button component in React with TypeScript that accepts variant, size, and disabled props, follows shadcn/ui patterns, and includes proper accessibility attributes"
```

### API Development
```
"Build a REST API endpoint in Express.js for user management that includes CRUD operations, input validation, error handling, and follows RESTful conventions"
```

### Test Creation
```
"Generate comprehensive unit tests for this utility function using Jest, including edge cases, error scenarios, and proper assertions"
```

### Function Development with TDD
Community-proven workflow:
```
"Create a function that [specific functionality]. Write tests first, then the code, then run the tests and update the code until tests pass"
```

### Build Error Resolution
```
"I have got some build errors, run 'nr build' to see the errors, and then fix them, and then run build until build passes"
```

---

## Claude Code Setup & Usage Guide

### Our Configuration

We use **Claude Code** (Anthropic's official CLI) with a sophisticated multi-agent architecture:

| Component | Details |
|-----------|---------|
| **Model** | Opus 4.5 (all agents) |
| **Global Agents** | 24 specialized agents at `~/.claude/agents/` |
| **Project Agents** | 47 project-specific agents at `.claude/agents/` |
| **Total Unique** | 71 agents (no duplicates) |
| **Stack** | Next.js 16 + React 19 + Prisma 6 + TypeScript 5 |

### Agent Categories

**Stack (7)**: nextjs, react, typescript, tailwind, prisma, shadcn, authjs

**Design (4)**: orchestration, architecture, pattern, structure

**UI (4)**: shadcn, atom, template, block

**DevOps (3)**: build, deploy, test

**VCS (2)**: git, github

**Specialized (4)**: middleware, internationalization, semantic, sse

### Directory Structure

```
~/.claude/                    # Global (all projects)
├── agents/                   # 24 specialized agents
│   ├── _index.md            # Agent registry
│   ├── architecture.md      # System design
│   ├── nextjs.md            # App Router expert
│   └── ...
├── CLAUDE.md                # Global instructions
└── settings.json            # Configuration

.claude/                      # Project-specific
├── agents/                   # 47 project agents
├── commands/                 # Custom slash commands
├── skills/                   # Reusable skills
└── hooks/                    # Automation hooks
```

### Usage Patterns

**Invoke agents by name:**
```
Use the architecture agent to design the data model.
Use the nextjs agent to create a new page with server actions.
Use the build agent to fix TypeScript errors.
```

**Task delegation syntax:**
```
@orchestration: Coordinate this complex feature
@architecture: Design the multi-tenant schema
@shadcn: Add required UI components
@build: Validate and build
@deploy: Ship to production
```

**Quick reference:**

| Need | Command |
|------|---------|
| New page/route | `Use nextjs agent` |
| Component optimization | `Use react agent` |
| Type errors | `Use typescript agent` |
| Database schema | `Use prisma agent` |
| UI components | `Use shadcn agent` |
| System design | `Use architecture agent` |
| File organization | `Use structure agent` |
| Build issues | `Use build agent` |
| Server errors | `Use sse agent` |

---

## Claude Code Performance Monitoring

### Key Metrics to Track

| Metric | How to Measure | Target |
|--------|----------------|--------|
| **Response Time** | Observe latency per request | &lt;5s for simple, &lt;30s for complex |
| **Token Usage** | Check Claude dashboard | Optimize prompts to reduce |
| **Agent Hit Rate** | Track which agents are used | >80% appropriate delegation |
| **Error Rate** | Count failed generations | &lt;5% retry rate |
| **Context Efficiency** | Monitor context window usage | &lt;70% capacity |

### Monitoring Commands

```bash
# Check session history
cat ~/.claude/history.jsonl | tail -20

# View agent usage stats
ls -la ~/.claude/agents/*.md | wc -l

# Check recent debug logs
ls ~/.claude/debug/ | tail -10

# Monitor active tasks
cat ~/.claude/todos/*.json 2>/dev/null | head -20
```

### Performance Dashboard Checklist

Track these weekly:

- [ ] Average response time per agent type
- [ ] Most frequently used agents
- [ ] Common error patterns
- [ ] Context window overflow incidents
- [ ] Token consumption trends
- [ ] Build success rate with AI assistance

### Session Analytics

**What to log:**
```markdown
## Session: 2024-01-15

### Tasks Completed
- Created student management feature (architecture + nextjs + prisma)
- Fixed 12 TypeScript errors (typescript agent)
- Deployed to staging (deploy agent)

### Agent Performance
| Agent | Invocations | Success Rate | Avg Time |
|-------|-------------|--------------|----------|
| architecture | 3 | 100% | 15s |
| nextjs | 5 | 100% | 8s |
| typescript | 12 | 92% | 3s |

### Issues Encountered
- Context overflow on large file reads
- Needed 2 retries for complex Prisma schema

### Improvements Made
- Split large prompts into smaller chunks
- Added more context in initial prompt
```

---

## Optimization Tips

### What We Could Do Better

#### 1. Prompt Optimization

**Before (inefficient):**
```
Create a component
```

**After (optimized):**
```
Use the shadcn agent to create a StudentCard component:
- Props: student object with name, email, grade
- Style: shadcn/ui Card with Avatar
- Include: edit and delete action buttons
- Follow: mirror pattern in components/platform/students/
```

#### 2. Context Management

**Problem**: Context window fills up with large files

**Solutions:**
- Read specific line ranges: `Read file lines 50-100`
- Use glob patterns for targeted searches
- Summarize large contexts before proceeding
- Clear irrelevant context between tasks

#### 3. Agent Selection

**Anti-pattern**: Using generic prompts
```
Fix this bug
```

**Best practice**: Invoke specific agents
```
Use the sse agent to diagnose server-side exception in /api/students
```

#### 4. Batch Operations

**Inefficient**: One file at a time
```
Create form.tsx
... wait ...
Create actions.ts
... wait ...
Create validation.ts
```

**Efficient**: Batch related tasks
```
Create the complete student feature following mirror pattern:
- components/platform/students/content.tsx
- components/platform/students/actions.ts
- components/platform/students/validation.ts
- components/platform/students/form.tsx
```

#### 5. Handoff Chain Optimization

**Use the handoff protocol:**
```
orchestration (coordinator)
├── architecture → pattern → structure
├── nextjs → react → typescript
├── shadcn → atom → template → block
└── build → deploy
```

**Example efficient flow:**
```
1. @architecture: Design student enrollment feature
2. @structure: Confirm file organization
3. @nextjs: Implement pages and server actions
4. @shadcn: Add UI components
5. @build: Validate and build
6. @deploy: Ship to staging
```

### Configuration Improvements

#### Agent Registry (`~/.claude/agents/_index.md`)

Keep it updated with:
- Accurate agent count
- Current technology versions
- Clear handoff chains
- Quick reference table

#### Global Instructions (`~/.claude/CLAUDE.md`)

Include:
- Default model preference (Opus 4.5)
- Package manager (pnpm)
- Tech stack versions
- Common patterns reference

#### Project Instructions (`.claude/CLAUDE.md`)

Document:
- Project-specific patterns
- Multi-tenant requirements
- Build commands
- Testing requirements

### Performance Checklist

**Daily:**
- [ ] Use specific agents for tasks
- [ ] Batch related operations
- [ ] Clear context between major tasks

**Weekly:**
- [ ] Review agent usage patterns
- [ ] Update outdated agent versions
- [ ] Clean up unused project agents
- [ ] Check for duplicate agents

**Monthly:**
- [ ] Audit global vs project agents
- [ ] Update technology versions in agents
- [ ] Review and optimize handoff chains
- [ ] Document new patterns discovered

### Cost Optimization

| Strategy | Savings |
|----------|---------|
| Use Haiku for simple tasks | 10x cheaper |
| Batch related operations | Fewer API calls |
| Optimize prompts | Fewer tokens |
| Cache common patterns | Reuse instead of regenerate |
| Use specific agents | Faster, more accurate |

### Red Flags to Watch

- **Context overflow**: Split large tasks
- **Repeated retries**: Improve prompt clarity
- **Wrong agent used**: Update quick reference
- **Slow responses**: Check network, simplify prompt
- **Inconsistent output**: Add more constraints

---

*Vibe coding represents the future of development - where human creativity meets AI capability. Focus on the big picture and let AI handle the details.* 