---
title: "Listings"
description: "A unified pattern for data tables, grids, and CRUD operations across the platform with optimistic updates, auto-refresh, and consistent UX."
---

## The Listings Block

**Listings** are the backbone of data-driven features in the platform. They provide a unified pattern for displaying, searching, filtering, creating, editing, and deleting recordsâ€”all with a consistent UX and optimistic updates.

Every listing in the platform follows the same structure, making it predictable for developers and consistent for users. Whether you're working with Students, Teachers, Classes, Events, or any other entityâ€”the pattern remains the same.

## Key Features

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6 not-prose">
  <div className="border rounded-lg p-6">
    <h4 className="font-semibold mb-2">Modal Auto-Close</h4>
    <p className="text-sm text-muted-foreground">Forms automatically close after successful create/update operations, providing immediate visual feedback.</p>
  </div>
  <div className="border rounded-lg p-6">
    <h4 className="font-semibold mb-2">Auto-Refresh</h4>
    <p className="text-sm text-muted-foreground">Lists update instantly without page reload using optimistic updates and the `usePlatformData` hook.</p>
  </div>
  <div className="border rounded-lg p-6">
    <h4 className="font-semibold mb-2">View Toggle</h4>
    <p className="text-sm text-muted-foreground">Switch between Table and Grid views with a single click. State persists across sessions.</p>
  </div>
  <div className="border rounded-lg p-6">
    <h4 className="font-semibold mb-2">Unified Toolbar</h4>
    <p className="text-sm text-muted-foreground">Consistent layout with search on the left, actions (view toggle, export, create) on the right.</p>
  </div>
</div>

## Architecture

Every listing consists of these co-located files following the mirror pattern:

```
components/platform/<feature>/
â”œâ”€â”€ table.tsx          # Main listing component (table + grid views)
â”œâ”€â”€ form.tsx           # Create/Edit form with onSuccess callback
â”œâ”€â”€ columns.tsx        # Column definitions for the table
â”œâ”€â”€ actions.ts         # Server actions (CRUD + CSV export)
â”œâ”€â”€ queries.ts         # Centralized query builders (NEW)
â”œâ”€â”€ authorization.ts   # Role-based access control (NEW)
â”œâ”€â”€ validation.ts      # Zod schemas
â”œâ”€â”€ types.ts           # TypeScript interfaces
â””â”€â”€ content.tsx        # Server component wrapper
```

### Reference Implementation: Announcements & Grades

The **Announcements** and **Grades** modules serve as reference implementations with the complete pattern including:

- **queries.ts**: Centralized query builders with type-safe Prisma queries
- **authorization.ts**: Role-based access control (RBAC)
- **`ActionResponse<T>`**: Typed success/error responses

## Core Components

### PlatformToolbar

The `PlatformToolbar` component provides a unified interface for all listings with a **compact inline layout**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [Search]  [Scope â–¾]  [Status â–¾]  [Reset]  [âŠ]  [â†“]  [Filters â–¾]  [+]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     Search    Custom Filters    Reset   View Export ColFilters  Create
```

**Layout:** All elements flow inline with consistent `gap-2` (8px) spacing.

**Components (left to right):**
- Search input with icon (`h-9`)
- Custom filter dropdowns via `additionalActions` (`h-9`)
- Reset button (when filters active) (`h-9`)
- View toggle (Table/Grid) (`h-9`)
- Export CSV button (`h-9`)
- Column visibility toggle (table view only)
- Create button (Plus icon) (`h-9`)

**Height Consistency:** All toolbar elements use `h-9` (36px) for visual consistency.

### usePlatformData Hook

The `usePlatformData` hook manages data state with optimistic updates:

```typescript
const {
  data,           // Current data array
  total,          // Total count for pagination
  isLoading,      // Loading state
  hasMore,        // Whether more data is available
  loadMore,       // Load more function
  refresh,        // Refresh data function
  optimisticRemove, // Remove item optimistically
} = usePlatformData<RowType, FilterType>({
  initialData,    // Initial data from server
  total,          // Total count from server
  perPage,        // Items per page (default: 20)
  fetcher,        // Async function to fetch data
  filters,        // Optional filter object
});
```

### usePlatformView Hook

The `usePlatformView` hook manages view mode (table/grid):

```typescript
const { view, toggleView } = usePlatformView({
  defaultView: "table"
});
```

## Advanced Patterns

### Debounced Search

Use `useDeferredValue` for natural debouncing (~300ms) without manual timers:

```typescript
import { useDeferredValue, useState } from "react";

// Search state with debouncing
const [searchInput, setSearchInput] = useState("");
const deferredSearch = useDeferredValue(searchInput);

// Handle search (no manual debounce needed)
const handleSearchChange = useCallback((value: string) => {
  setSearchInput(value);
}, []);

// Use deferredSearch in data fetcher
const { data } = usePlatformData({
  fetcher: async (params) => {
    const result = await getItems({
      ...params,
      title: deferredSearch || undefined,
    });
    return { rows: result.rows, total: result.total };
  },
  filters: deferredSearch ? { title: deferredSearch } : undefined,
});
```

### Column Filters (Preferred Approach)

Use **column filters** (dropdown in table headers) instead of custom toolbar dropdowns for simpler, less duplicated UI:

```typescript
// columns.tsx - Enable column filters with select options
{
  accessorKey: "scope",
  header: ({ column }) => <DataTableColumnHeader column={column} title={t.scope} />,
  cell: ({ getValue }) => {
    const scope = getValue<string>();
    const labels: Record<string, string> = {
      school: t.schoolWide,  // "School" / "Ù…Ø¯Ø±Ø³Ø©"
      class: t.classSpecific, // "Class" / "ÙØµÙ„"
      role: t.roleSpecific,   // "Role" / "Ø¯ÙˆØ±"
    };
    return <span className="text-sm">{labels[scope] || scope}</span>;
  },
  meta: {
    label: t.scope,
    variant: "select",
    options: [
      { label: t.schoolWide, value: "school" },
      { label: t.classSpecific, value: "class" },
      { label: t.roleSpecific, value: "role" },
    ],
  },
  enableColumnFilter: true,
  filterFn: (row, id, value) => value.includes(row.getValue(id)),
},
{
  accessorKey: "published",
  header: ({ column }) => <DataTableColumnHeader column={column} title={t.status} />,
  cell: ({ getValue }) => {
    const is = getValue<boolean>();
    return <Badge variant={is ? "default" : "outline"}>{is ? t.published : t.draft}</Badge>;
  },
  meta: {
    label: t.status,
    variant: "select",
    options: [
      { label: t.published, value: "true" },
      { label: t.draft, value: "false" },
    ],
  },
  enableColumnFilter: true,
  filterFn: (row, id, value) => value.includes(String(row.getValue(id))),
},
```

**Key Points:**
- Use **simplified labels** in dictionary: "School" not "School-wide", "Ù…Ø¯Ø±Ø³Ø©" not "Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø¯Ø±Ø³Ø©"
- Column filters work on already-loaded data (client-side filtering)
- No need for custom toolbar dropdowns - cleaner, less code
- Pass translated options via `meta.options`

### Simplified Dictionary Labels

For filter dropdowns and column displays, use concise labels:

```json
// English
{
  "schoolWide": "School",      // Not "School-wide"
  "classSpecific": "Class",    // Not "Class Specific"
  "roleSpecific": "Role"       // Not "Role Specific"
}

// Arabic
{
  "schoolWide": "Ù…Ø¯Ø±Ø³Ø©",        // Not "Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø¯Ø±Ø³Ø©"
  "classSpecific": "ÙØµÙ„",       // Not "ÙØµÙ„ Ù…Ø­Ø¯Ø¯"
  "roleSpecific": "Ø¯ÙˆØ±"         // Not "Ø¯ÙˆØ± Ù…Ø­Ø¯Ø¯"
}
```

### Language-Based Filtering (i18n)

For bilingual platforms, filter data by the user's current locale:

```typescript
interface TableProps {
  initialData: RowType[];
  total: number;
  dictionary: Dictionary['school']['announcements'];
  lang: Locale;  // Current locale from route params
}

export function Table({ initialData, total, dictionary, lang }: TableProps) {
  const t = dictionary;

  // Always include language filter for locale-based content
  const filters = useMemo(() => {
    const f: Record<string, unknown> = {
      language: lang,  // Always filter by current locale
    };
    if (deferredSearch) f.title = deferredSearch;
    if (scopeFilter !== "all") f.scope = scopeFilter;
    return f;
  }, [lang, deferredSearch, scopeFilter]);

  // In fetcher, always pass language
  const { data } = usePlatformData({
    fetcher: async (params) => {
      const result = await getItems({
        ...params,
        language: lang,  // Filter by locale
      });
      return { rows: result.rows, total: result.total };
    },
    filters,
  });
}
```

**Key Points:**
- Pass `lang` from route params to table component
- Add `language` field to Prisma model with default (e.g., `"ar"`)
- Always include `language` filter in queries
- Create separate content for each locale (not bilingual content in single records)

### Column Filters vs Toolbar Filters

**Prefer column filters** over custom toolbar dropdowns:

```typescript
// âœ… PREFERRED: Column filters (built into DataTable)
{
  accessorKey: "scope",
  meta: {
    variant: "select",
    options: [...],
  },
  enableColumnFilter: true,  // Dropdown in column header
}

// âŒ AVOID: Custom toolbar dropdowns (duplicates column filters)
// Only use additionalActions for filters NOT available as columns
const filterDropdowns = (
  <Select value={scopeFilter} onValueChange={setScopeFilter}>
    {/* ... */}
  </Select>
);
<PlatformToolbar additionalActions={filterDropdowns} />
```

**When to Use Toolbar Filters:**
- Complex multi-field filters that span multiple columns
- Date range pickers or other specialized inputs
- Filters for data not shown in columns

**When to Use Column Filters:**
- Simple select/checkbox filters for column values
- Status, scope, type, category filters
- Any filterable column already displayed

## Optimistic Callbacks Pattern

### Why Use Callbacks?

The **callback pattern** separates delete logic from column definitions, enabling:

1. **Optimistic Updates**: Remove items instantly before server confirms
2. **Better Separation**: Columns define UI, table handles logic
3. **Easier Testing**: Logic in table component, not nested in columns
4. **No SSR Issues**: Hooks remain in client components only

### Column Callbacks Interface

```typescript
// columns.tsx
export interface ColumnCallbacks {
  onDelete?: (row: RowType) => void;
  onToggleStatus?: (row: RowType) => void;
  // Add other actions as needed
}

export const getColumns = (
  dictionary: Dictionary['school']['feature'],
  locale: Locale,
  callbacks?: ColumnCallbacks
): ColumnDef<RowType>[] => [
  // ... column definitions
  {
    id: "actions",
    cell: ({ row }) => {
      const item = row.original;
      const { openModal } = useModal();

      const onDelete = () => {
        callbacks?.onDelete?.(item);  // Use callback instead of inline delete
      };

      return (
        <DropdownMenu>
          {/* ... */}
          <DropdownMenuItem onClick={onDelete}>Delete</DropdownMenuItem>
        </DropdownMenu>
      );
    },
  },
];
```

### Pass Callbacks from Table

```typescript
// table.tsx
// IMPORTANT: Define handleDelete BEFORE the columns useMemo
const handleDelete = useCallback(async (item: RowType) => {
  const ok = await confirmDeleteDialog(`Delete ${item.name}?`);
  if (!ok) return;

  // Optimistic remove
  optimisticRemove(item.id);

  const result = await deleteItem({ id: item.id });
  if (result.success) {
    DeleteToast();
  } else {
    // Revert on error
    refresh();
    ErrorToast("Failed to delete");
  }
}, [optimisticRemove, refresh]);

// Pass callback to columns
const columns = useMemo(() => getColumns(dictionary, lang, {
  onDelete: handleDelete,
}), [dictionary, lang, handleDelete]);
```

### Simplified Action Labels

Use simple, generic labels in dropdown menus instead of entity-specific labels:

```typescript
// columns.tsx - Action cell
<DropdownMenuItem onClick={onView}>
  {locale === 'ar' ? 'Ø¹Ø±Ø¶' : 'View'}
</DropdownMenuItem>
<DropdownMenuItem onClick={onEdit}>
  {locale === 'ar' ? 'ØªØ¹Ø¯ÙŠÙ„' : 'Edit'}
</DropdownMenuItem>
<DropdownMenuItem onClick={onDelete}>
  {locale === 'ar' ? 'Ø­Ø°Ù' : 'Delete'}
</DropdownMenuItem>

// âœ… CORRECT: "View", "Edit", "Delete"
// âŒ AVOID: "View Student", "Edit Student", "Delete Student"
```

**Benefits:**
- Cleaner UI with shorter labels
- No need for entity-specific dictionary keys
- Consistent across all modules

---

## Implementation Guide

### 1. Table Component (table.tsx)

```typescript
"use client";

import { useMemo, useState, useCallback, useTransition } from "react";
import { DataTable } from "@/components/table/data-table";
import { useDataTable } from "@/components/table/use-data-table";
import { getColumns, type RowType } from "./columns";
import { useModal } from "@/components/atom/modal/context";
import Modal from "@/components/atom/modal/modal";
import { CreateForm } from "./form";
import { getItems, getItemsCSV, deleteItem } from "./actions";
import { usePlatformView } from "@/hooks/use-platform-view";
import { usePlatformData } from "@/hooks/use-platform-data";
import {
  PlatformToolbar,
  GridCard,
  GridContainer,
  GridEmptyState,
} from "@/components/platform/shared";
import { useRouter } from "next/navigation";
import { DeleteToast, ErrorToast, confirmDeleteDialog } from "@/components/atom/toast";

interface TableProps {
  initialData: RowType[];
  total: number;
  perPage?: number;
}

export function ItemsTable({ initialData, total, perPage = 20 }: TableProps) {
  const router = useRouter();
  const { openModal } = useModal();
  const [isPending, startTransition] = useTransition();

  // View mode (table/grid)
  const { view, toggleView } = usePlatformView({ defaultView: "table" });

  // Search state
  const [searchValue, setSearchValue] = useState("");

  // Data management with optimistic updates
  const {
    data,
    isLoading,
    hasMore,
    loadMore,
    refresh,
    optimisticRemove,
  } = usePlatformData<RowType, { name?: string }>({
    initialData,
    total,
    perPage,
    fetcher: async (params) => {
      const result = await getItems(params);
      return { rows: result.rows, total: result.total };
    },
    filters: searchValue ? { name: searchValue } : undefined,
  });

  // Columns (memoized)
  const columns = useMemo(() => getColumns(), []);

  // Table instance
  const { table } = useDataTable<RowType>({
    data,
    columns,
    pageCount: 1,
    initialState: {
      pagination: { pageIndex: 0, pageSize: data.length || perPage }
    }
  });

  // Handlers
  const handleSearchChange = useCallback((value: string) => {
    setSearchValue(value);
    startTransition(() => router.refresh());
  }, [router]);

  const handleDelete = useCallback(async (item: RowType) => {
    const ok = await confirmDeleteDialog(`Delete ${item.name}?`);
    if (!ok) return;
    optimisticRemove(item.id);
    const result = await deleteItem({ id: item.id });
    if (!result.success) {
      refresh();
      ErrorToast("Failed to delete");
    } else {
      DeleteToast();
    }
  }, [optimisticRemove, refresh]);

  const handleExportCSV = useCallback(async (filters?: Record<string, unknown>) => {
    return getItemsCSV(filters);
  }, []);

  return (
    <>
      <PlatformToolbar
        table={view === "table" ? table : undefined}
        view={view}
        onToggleView={toggleView}
        searchValue={searchValue}
        onSearchChange={handleSearchChange}
        searchPlaceholder="Search..."
        onCreate={() => openModal()}
        getCSV={handleExportCSV}
        entityName="items"
      />

      {view === "table" ? (
        <DataTable
          table={table}
          paginationMode="load-more"
          hasMore={hasMore}
          isLoading={isLoading || isPending}
          onLoadMore={loadMore}
        />
      ) : (
        <GridContainer columns={3}>
          {data.map((item) => (
            <GridCard
              key={item.id}
              title={item.name}
              // ... grid card props
            />
          ))}
        </GridContainer>
      )}

      <Modal content={<CreateForm onSuccess={refresh} />} />
    </>
  );
}
```

### 2. Form Component (form.tsx)

```typescript
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { toast } from "sonner";
import { createItem, getItem, updateItem } from "./actions";
import { itemSchema, type ItemFormData } from "./validation";
import { useModal } from "@/components/atom/modal/context";
import { useRouter } from "next/navigation";

interface FormProps {
  /** Callback fired on successful create/update - use for optimistic refresh */
  onSuccess?: () => void;
}

export function CreateForm({ onSuccess }: FormProps) {
  const { modal, closeModal } = useModal();
  const router = useRouter();

  const form = useForm<ItemFormData>({
    resolver: zodResolver(itemSchema),
    defaultValues: { name: "" },
  });

  const currentId = modal.id || undefined;
  const isView = modal.id?.startsWith("view:");

  // Load existing data for edit mode
  useEffect(() => {
    if (!currentId || isView) return;
    getItem({ id: currentId }).then((res) => {
      if (res.item) form.reset(res.item);
    });
  }, [currentId]);

  async function onSubmit(values: ItemFormData) {
    const res = currentId
      ? await updateItem({ id: currentId, ...values })
      : await createItem(values);

    if (res?.success) {
      toast.success(currentId ? "Updated" : "Created");
      closeModal();
      // Use callback for optimistic update, fallback to router.refresh()
      if (onSuccess) {
        onSuccess();
      } else {
        router.refresh();
      }
    } else {
      toast.error("Failed");
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
}
```

### 3. Actions (actions.ts)

```typescript
"use server";

import { z } from "zod";
import { revalidatePath } from "next/cache";
import { db } from "@/lib/db";
import { getTenantContext } from "@/lib/tenant-context";
import { itemSchema, getItemsSchema } from "./validation";

export async function createItem(input: z.infer<typeof itemSchema>) {
  const { schoolId } = await getTenantContext();
  if (!schoolId) throw new Error("Missing school context");

  const parsed = itemSchema.parse(input);
  const row = await db.item.create({
    data: { schoolId, ...parsed },
  });

  revalidatePath("/items");
  return { success: true, id: row.id };
}

export async function getItems(input: Partial<z.infer<typeof getItemsSchema>>) {
  const { schoolId } = await getTenantContext();
  if (!schoolId) throw new Error("Missing school context");

  const sp = getItemsSchema.parse(input ?? {});
  const where = {
    schoolId,
    ...(sp.name ? { name: { contains: sp.name, mode: "insensitive" } } : {}),
  };

  const [rows, count] = await Promise.all([
    db.item.findMany({ where, skip: (sp.page - 1) * sp.perPage, take: sp.perPage }),
    db.item.count({ where }),
  ]);

  return { rows, total: count };
}

export async function getItemsCSV(input?: Partial<z.infer<typeof getItemsSchema>>) {
  const { schoolId } = await getTenantContext();
  if (!schoolId) throw new Error("Missing school context");

  const items = await db.item.findMany({ where: { schoolId } });

  const headers = ["ID", "Name", "Created"];
  const csvRows = items.map((item) =>
    [item.id, `"${item.name}"`, item.createdAt.toISOString()].join(",")
  );

  return [headers.join(","), ...csvRows].join("\n");
}
```

## Grid View Components

### GridContainer

Responsive grid layout:

```typescript
<GridContainer columns={3}>
  {data.map((item) => (
    <GridCard key={item.id} {...props} />
  ))}
</GridContainer>
```

### GridCard

Card component for grid view:

```typescript
<GridCard
  title={item.name}
  subtitle={item.description}
  avatarFallback="AB"
  status={{ label: "Active", variant: "default" }}
  metadata={[
    { label: "Type", value: item.type },
    { label: "Count", value: item.count },
  ]}
  actions={[
    { label: "View", onClick: () => handleView(item.id) },
    { label: "Edit", onClick: () => handleEdit(item.id) },
    { label: "Delete", onClick: () => handleDelete(item), variant: "destructive" },
  ]}
  onClick={() => handleView(item.id)}
/>
```

### GridEmptyState

Empty state for grid view:

```typescript
<GridEmptyState
  title="No Items Found"
  description="Create your first item to get started"
  icon={<Package className="h-12 w-12" />}
/>
```

## Modal Pattern

### Opening Modals

```typescript
const { openModal } = useModal();

// Create mode (no ID)
openModal();

// Edit mode (with ID)
openModal(item.id);

// View mode (with view: prefix)
openModal(`view:${item.id}`);
```

### Modal Detection in Forms

```typescript
const { modal, closeModal } = useModal();

const isView = modal.id?.startsWith("view:");
const currentId = modal.id
  ? (modal.id.startsWith("view:") ? modal.id.split(":")[1] : modal.id)
  : undefined;
const isEdit = !!currentId && !isView;
const isCreate = !currentId;
```

## Modal Form Layout

All listing modals follow the **onboarding layout pattern** with:
- Fullscreen modal with vertical centering
- Two-column grid layout (title/description + form)
- Fixed footer with progress bar and step navigation
- Consistent typography and spacing

### Layout Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚                                                             â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚   â”‚  â”‚  Title (h1)      â”‚    â”‚  Form Fields               â”‚   â”‚   â”‚
â”‚   â”‚  â”‚  Description     â”‚    â”‚  - Input 1                 â”‚   â”‚   â”‚
â”‚   â”‚  â”‚  (muted text)    â”‚    â”‚  - Input 2                 â”‚   â”‚   â”‚
â”‚   â”‚  â”‚                  â”‚    â”‚  - ...                     â”‚   â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚   â”‚                                                             â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [Progress Bar]                                                      â”‚
â”‚  Step 1 of 3: Basic Information            [Cancel] [Save] [Next]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Components

#### ModalFormLayout

Shared two-column layout wrapper for all listing forms:

```typescript
import { ModalFormLayout } from "@/components/atom/modal/modal-form-layout";

<ModalFormLayout
  title={isView ? "View Student" : currentId ? "Edit Student" : "Create Student"}
  description={isView
    ? "View student details"
    : currentId
      ? "Update student information"
      : "Add a new student to the school"
  }
>
  {renderCurrentStep()}
</ModalFormLayout>
```

**Props:**
- `title`: Modal heading (text-3xl font-bold)
- `description`: Subtitle (text-muted-foreground)
- `children`: Form content for current step

#### ModalFooter

Fixed footer with progress bar and navigation:

```typescript
import { ModalFooter } from "@/components/atom/modal/modal-footer";

<ModalFooter
  currentStep={currentStep}
  totalSteps={3}
  stepLabel={stepLabels[currentStep]}
  isView={isView}
  isEdit={!!currentId}
  isDirty={form.formState.isDirty}
  onBack={handleBack}
  onNext={handleNext}
  onSaveStep={handleSaveCurrentStep}
  labels={{
    cancel: dictionary?.cancel,
    back: dictionary?.back,
    next: dictionary?.next,
    save: dictionary?.save,
    create: dictionary?.create,
  }}
/>
```

**Props:**
- `currentStep`: Current step number (1-indexed)
- `totalSteps`: Total number of steps
- `stepLabel`: Label for current step (e.g., "Basic Information")
- `isView`: Read-only mode
- `isEdit`: Edit mode (shows Save button)
- `isDirty`: Form has unsaved changes
- `onBack`: Back/Cancel handler
- `onNext`: Next/Create handler
- `onSaveStep`: Save current step handler (edit mode)
- `labels`: Optional i18n labels object

### Complete Form Example

```typescript
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form } from "@/components/ui/form";
import { useModal } from "@/components/atom/modal/context";
import { ModalFormLayout } from "@/components/atom/modal/modal-form-layout";
import { ModalFooter } from "@/components/atom/modal/modal-footer";
import { BasicInfoStep } from "./basic-info";
import { DetailsStep } from "./details";
import { schema } from "./validation";

export function CreateForm({ onSuccess }: { onSuccess?: () => void }) {
  const { modal, closeModal } = useModal();
  const [currentStep, setCurrentStep] = useState(1);

  const form = useForm({
    resolver: zodResolver(schema),
    defaultValues: { /* ... */ },
  });

  const isView = modal.id?.startsWith("view:");
  const currentId = modal.id
    ? (modal.id.startsWith("view:") ? modal.id.split(":")[1] : modal.id)
    : undefined;

  const stepLabels: Record<number, string> = {
    1: "Basic Information",
    2: "Details",
  };

  const handleNext = async () => {
    if (currentStep === 1) {
      const valid = await form.trigger(['name', 'email']);
      if (valid) setCurrentStep(2);
    } else {
      await form.handleSubmit(onSubmit)();
    }
  };

  const handleBack = () => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1);
    } else {
      closeModal();
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={(e) => e.preventDefault()}>
        <ModalFormLayout
          title={isView ? "View Item" : currentId ? "Edit Item" : "Create Item"}
          description={isView ? "View details" : currentId ? "Update details" : "Add new item"}
        >
          {currentStep === 1 && <BasicInfoStep form={form} isView={isView} />}
          {currentStep === 2 && <DetailsStep form={form} isView={isView} />}
        </ModalFormLayout>

        <ModalFooter
          currentStep={currentStep}
          totalSteps={2}
          stepLabel={stepLabels[currentStep]}
          isView={isView}
          isEdit={!!currentId}
          isDirty={form.formState.isDirty}
          onBack={handleBack}
          onNext={handleNext}
          onSaveStep={handleNext}
        />
      </form>
    </Form>
  );
}
```

### Styling Reference

The modal layout uses these key patterns:

| Element | Classes |
|---------|---------|
| Modal wrapper | `flex-1 flex items-center justify-center pb-20` |
| Content max-width | `max-w-6xl mx-auto w-full` |
| Grid layout | `grid grid-cols-1 lg:grid-cols-2 gap-6 lg:gap-20` |
| Title | `text-3xl font-bold` |
| Description | `text-sm sm:text-base text-muted-foreground leading-relaxed` |
| Footer | `fixed bottom-0 left-0 right-0 bg-background border-t` |
| Progress bar | `h-1` (Progress component) |

### Footer Height Calculation

The `pb-20` (80px) accounts for the fixed footer height:
- Progress bar container: ~12px
- Button row with padding: ~68px
- Total: ~80px

## Optimistic Updates

### Why Optimistic Updates?

Instead of waiting for server response, we update the UI immediately:

1. **Better UX**: Instant visual feedback
2. **Perceived Performance**: App feels faster
3. **Error Recovery**: Revert on failure

### Implementation Flow

```
User Action â†’ Optimistic UI Update â†’ Server Request â†’
  â”œâ”€â”€ Success: Keep UI state
  â””â”€â”€ Failure: Revert UI + Show error
```

### Delete with Optimistic Update

```typescript
const handleDelete = useCallback(async (item: RowType) => {
  const ok = await confirmDeleteDialog(`Delete ${item.name}?`);
  if (!ok) return;

  // 1. Optimistic remove from UI
  optimisticRemove(item.id);

  // 2. Server request
  const result = await deleteItem({ id: item.id });

  if (result.success) {
    // 3a. Success: Show toast
    DeleteToast();
  } else {
    // 3b. Failure: Revert + error
    refresh();
    ErrorToast("Failed to delete");
  }
}, [optimisticRemove, refresh]);
```

## Export Pattern

### CSV Export

All listings support CSV export through `getXXXCSV` server actions:

```typescript
export async function getItemsCSV(input?: Partial<z.infer<typeof getItemsSchema>>) {
  const { schoolId } = await getTenantContext();
  if (!schoolId) throw new Error("Missing school context");

  const items = await db.item.findMany({
    where: { schoolId },
    orderBy: [{ createdAt: "desc" }],
  });

  const headers = ["ID", "Name", "Email", "Status", "Created"];
  const csvRows = items.map((item) =>
    [
      item.id,
      `"${(item.name || "").replace(/"/g, '""')}"`,
      `"${(item.email || "").replace(/"/g, '""')}"`,
      item.status,
      new Date(item.createdAt).toISOString().split("T")[0],
    ].join(",")
  );

  return [headers.join(","), ...csvRows].join("\n");
}
```

### Export Button

The `PlatformToolbar` handles export automatically:

```typescript
<PlatformToolbar
  getCSV={handleExportCSV}
  entityName="items"  // Used for filename: items.csv
/>
```

## Modules Using This Pattern

| Module | Table | Grid | Search | Export |
|--------|-------|------|--------|--------|
| **Students** | Yes | Yes | Yes | Yes |
| **Teachers** | Yes | Yes | Yes | Yes |
| **Subjects** | Yes | Yes | Yes | Yes |
| **Announcements** | Yes | Yes | Yes | Yes |
| **Classes** | Yes | Yes | Yes | Yes |
| **Events** | Yes | Yes | Yes | Yes |
| **Grades** | Yes | Yes | Yes | Yes |
| **Lessons** | Yes | Yes | Yes | Yes |
| **Parents** | Yes | Yes | Yes | Yes |

## Best Practices

### 1. Toolbar Height Consistency

All toolbar elements must use `h-9` (36px) for visual consistency. **Important:** SelectTrigger uses `py-2` by default while Input uses `py-1`â€”add `py-1` to SelectTrigger for identical appearance:

```typescript
// âœ… CORRECT - consistent height AND padding
<Input className="h-9 w-40 pl-8" />          // h-9 + py-1 (default)
<SelectTrigger className="h-9 w-32 py-1" />  // h-9 + py-1 (override)
<Button size="icon" className="h-9 w-9" />   // h-9 w-9
<ViewToggle className="h-9 w-9 p-0" />       // h-9 w-9 p-0

// âŒ WRONG - inconsistent heights or padding
<Input className="h-8" />              // 32px
<SelectTrigger className="h-9 w-32" /> // h-9 but py-2 makes content smaller
<Button className="h-10" />            // 40px
```

### 2. Always Use `onSuccess` Callback

```typescript
// In form component
if (onSuccess) {
  onSuccess();
} else {
  router.refresh();
}

// In table component
<Modal content={<CreateForm onSuccess={refresh} />} />
```

### 2. Memoize Columns

```typescript
const columns = useMemo(() => getColumns(dictionary), [dictionary]);
```

### 3. Internationalized Page Navigation

Use dictionary translations for page-nav items. **Prefer useful pages over filter duplicates:**

```typescript
// layout.tsx
export default async function Layout({ children, params }: Props) {
  const { lang } = await params;
  const dictionary = await getDictionary(lang as Locale);
  const d = dictionary?.school?.announcements;

  // âœ… CORRECT: Useful production pages (not filter duplicates)
  // Column filters already handle Published/Drafts filtering
  const pages: PageNavItem[] = [
    { name: d?.navAll || 'All', href: `/${lang}/announcements` },
    { name: d?.navConfig || 'Config', href: `/${lang}/announcements/config` },
    { name: d?.navArchived || 'Archived', href: `/${lang}/announcements/archived` },
  ];

  // âŒ AVOID: Filter duplicates (use column filters instead)
  // { name: 'Published', href: `/${lang}/announcements/published` },
  // { name: 'Drafts', href: `/${lang}/announcements/drafts` },
  // { name: 'Scheduled', href: `/${lang}/announcements/scheduled` },

  return (
    <div className="space-y-6">
      <PageHeadingSetter title={d?.title || 'Announcements'} />
      <PageNav pages={pages} />
      {children}
    </div>
  );
}
```

**Dictionary keys:**
```json
{
  "navAll": "All",
  "navConfig": "Config",
  "navArchived": "Archived"
}
```

**Page-Nav Best Practices:**
- Use for **distinct functionality** (Config, Archived, Analytics)
- **Don't duplicate filters** (Published, Drafts) - column filters handle this
- Create **actual pages** for each nav item
- Keep navigation **concise** (3-4 items max)

### 4. Handle Loading States

```typescript
<DataTable
  isLoading={isLoading || isPending}
  // ...
/>
```

### 5. Include schoolId in All Queries

```typescript
const { schoolId } = await getTenantContext();
if (!schoolId) throw new Error("Missing school context");

await db.item.findMany({
  where: { schoolId, ...filters }
});
```

### 6. Provide Grid View Fallback

```typescript
{data.length === 0 ? (
  <GridEmptyState title="No Items" description="Add your first item" />
) : (
  <GridContainer columns={3}>
    {/* Grid cards */}
  </GridContainer>
)}
```

## Shared Components

All shared listing components are exported from:

```typescript
import {
  PlatformToolbar,
  GridCard,
  GridContainer,
  GridEmptyState,
  ExportButton,
  ViewToggle,
} from "@/components/platform/shared";
```

---

## From CRUD to Connected System

Basic CRUD listings are useful, but **production-ready listings connect to each other**. The difference:

```
ISOLATED (Level 1)              CONNECTED (Level 3+)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Students â”‚ â”‚ Grades  â”‚        â”‚   STUDENTS                  â”‚
â”‚  CRUD   â”‚ â”‚  CRUD   â”‚   â†’    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚ â”‚ Ahmed (10A)             â”‚ â”‚
    â†“           â†“              â”‚ â”‚ 3 classes | 92% attend  â”‚ â”‚
 (nothing connects them)       â”‚ â”‚ [â†’ Grades] [â†’ Classes]  â”‚ â”‚
                               â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5 Levels of Listing Maturity

| Level | Feature | Status |
|-------|---------|--------|
| **1** | Basic CRUD (create, read, update, delete) | âœ… Complete |
| **2** | Relationship context (counts, quick links) | ğŸ”„ In Progress |
| **3** | Rich detail pages with related data tabs | ğŸ”„ In Progress |
| **4** | Cross-listing actions (bulk operations) | ğŸ”„ In Progress |
| **5** | Automated workflows (triggers, notifications) | â³ Planned |

---

## Relationship Data in Rows

Show computed relationship data directly in listing rows:

```typescript
// content.tsx - Query with relationship counts
const students = await db.student.findMany({
  where: { schoolId },
  include: {
    _count: {
      select: {
        studentClasses: true,  // How many classes enrolled
        attendances: true,     // For attendance calculation
        results: true,         // How many grades
      }
    }
  }
});

// Map to row type with computed fields
const rows = students.map(s => ({
  ...s,
  classCount: s._count.studentClasses,
  gradeCount: s._count.results,
  // Calculate attendance % if needed
}));
```

```typescript
// columns.tsx - Display relationship counts
{
  accessorKey: "classCount",
  header: "Classes",
  cell: ({ getValue }) => (
    <Badge variant="outline">{getValue<number>()} classes</Badge>
  ),
},
{
  accessorKey: "gradeCount",
  header: "Grades",
  cell: ({ getValue }) => (
    <Badge variant="outline">{getValue<number>()} grades</Badge>
  ),
},
```

**Apply to:**
- **Students**: class count, attendance %, grade count
- **Classes**: enrolled students (real count, not hardcoded!)
- **Teachers**: classes taught, student count

---

## Quick Actions Pattern

Add navigation links in action dropdowns to jump to related data:

```typescript
// columns.tsx - In actions cell
<DropdownMenu>
  <DropdownMenuTrigger asChild>
    <Button variant="ghost" size="icon">
      <MoreHorizontal className="h-4 w-4" />
    </Button>
  </DropdownMenuTrigger>
  <DropdownMenuContent align="end">
    <DropdownMenuItem onClick={() => openModal(`view:${row.id}`)}>
      <Eye className="mr-2 h-4 w-4" />
      {locale === 'ar' ? 'Ø¹Ø±Ø¶' : 'View'}
    </DropdownMenuItem>
    <DropdownMenuItem onClick={() => openModal(row.id)}>
      <Pencil className="mr-2 h-4 w-4" />
      {locale === 'ar' ? 'ØªØ¹Ø¯ÙŠÙ„' : 'Edit'}
    </DropdownMenuItem>

    <DropdownMenuSeparator />

    {/* Quick navigation to related data */}
    <DropdownMenuItem asChild>
      <Link href={`/${locale}/grades?studentId=${row.id}`}>
        <GraduationCap className="mr-2 h-4 w-4" />
        {locale === 'ar' ? 'Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ø±Ø¬Ø§Øª' : 'View Grades'}
      </Link>
    </DropdownMenuItem>
    <DropdownMenuItem asChild>
      <Link href={`/${locale}/attendance?studentId=${row.id}`}>
        <CalendarCheck className="mr-2 h-4 w-4" />
        {locale === 'ar' ? 'Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø¶ÙˆØ±' : 'View Attendance'}
      </Link>
    </DropdownMenuItem>
    <DropdownMenuItem asChild>
      <Link href={`/${locale}/classes?studentId=${row.id}`}>
        <School className="mr-2 h-4 w-4" />
        {locale === 'ar' ? 'Ø¹Ø±Ø¶ Ø§Ù„ÙØµÙˆÙ„' : 'View Classes'}
      </Link>
    </DropdownMenuItem>

    <DropdownMenuSeparator />

    <DropdownMenuItem onClick={onDelete} className="text-destructive">
      <Trash2 className="mr-2 h-4 w-4" />
      {locale === 'ar' ? 'Ø­Ø°Ù' : 'Delete'}
    </DropdownMenuItem>
  </DropdownMenuContent>
</DropdownMenu>
```

**Standard quick links by entity:**
- **Student** â†’ View Grades, View Attendance, View Classes
- **Class** â†’ View Students, View Assignments, View Exams
- **Teacher** â†’ View Classes, View Schedule
- **Grade** â†’ View Student, View Class
- **Assignment** â†’ View Submissions

---

## Detail Pages with Related Data

Rich detail pages show the entity plus all related data in tabs:

```typescript
// [id]/page.tsx - Detail page with tabs
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

export default async function StudentDetailPage({ params }) {
  const student = await getStudentWithRelations(params.id);

  return (
    <div className="space-y-6">
      {/* Header with basic info */}
      <StudentHeader student={student} />

      {/* Tabs for related data */}
      <Tabs defaultValue="overview">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="classes">
            Classes ({student.classes.length})
          </TabsTrigger>
          <TabsTrigger value="grades">
            Grades ({student.grades.length})
          </TabsTrigger>
          <TabsTrigger value="attendance">
            Attendance ({student.attendanceRate}%)
          </TabsTrigger>
        </TabsList>

        <TabsContent value="overview">
          <StudentOverview student={student} />
        </TabsContent>
        <TabsContent value="classes">
          <StudentClasses classes={student.classes} />
        </TabsContent>
        <TabsContent value="grades">
          <StudentGrades grades={student.grades} />
        </TabsContent>
        <TabsContent value="attendance">
          <StudentAttendance records={student.attendances} />
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

**Required detail pages:**
- **Student** â†’ Overview, Classes, Grades, Attendance
- **Class** â†’ Overview, Students, Assignments, Schedule
- **Teacher** â†’ Overview, Classes, Schedule

---

## Bulk Operations Pattern

Enable multi-select and batch actions across listings:

### 1. Add Selection Column

```typescript
// columns.tsx - Add selection column as first column
import { Checkbox } from "@/components/ui/checkbox";

export const getColumns = (/* ... */): ColumnDef<RowType>[] => [
  {
    id: "select",
    header: ({ table }) => (
      <Checkbox
        checked={table.getIsAllPageRowsSelected()}
        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(value) => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  // ... other columns
];
```

### 2. Bulk Actions Toolbar

```typescript
// table.tsx - Show bulk actions when rows selected
const selectedRows = table.getFilteredSelectedRowModel().rows;

return (
  <>
    {selectedRows.length > 0 && (
      <BulkActionsToolbar
        selectedCount={selectedRows.length}
        onClearSelection={() => table.resetRowSelection()}
        actions={[
          {
            label: locale === 'ar' ? 'Ø­Ø°Ù Ø§Ù„Ù…Ø­Ø¯Ø¯' : 'Delete Selected',
            icon: <Trash2 className="h-4 w-4" />,
            variant: 'destructive',
            onClick: () => handleBulkDelete(selectedRows.map(r => r.original)),
          },
          {
            label: locale === 'ar' ? 'ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©' : 'Change Status',
            icon: <RefreshCw className="h-4 w-4" />,
            onClick: () => handleBulkStatusChange(selectedRows.map(r => r.original)),
          },
          // Custom actions per listing
          {
            label: locale === 'ar' ? 'Ø¥Ø¶Ø§ÙØ© Ù„ÙØµÙ„' : 'Enroll in Class',
            icon: <UserPlus className="h-4 w-4" />,
            onClick: () => handleBulkEnroll(selectedRows.map(r => r.original)),
          },
        ]}
      />
    )}

    <DataTable table={table} /* ... */ />
  </>
);
```

### 3. Bulk Server Actions

```typescript
// actions.ts - Bulk operations
export async function bulkDeleteStudents(input: { ids: string[] }) {
  const { schoolId } = await getTenantContext();
  if (!schoolId) throw new Error("Missing school context");

  await db.student.deleteMany({
    where: {
      id: { in: input.ids },
      schoolId, // Always scope by tenant!
    },
  });

  revalidatePath("/students");
  return { success: true, count: input.ids.length };
}

export async function bulkEnrollInClass(input: {
  studentIds: string[];
  classId: string;
}) {
  const { schoolId } = await getTenantContext();
  if (!schoolId) throw new Error("Missing school context");

  // Create StudentClass records for each student
  await db.studentClass.createMany({
    data: input.studentIds.map(studentId => ({
      studentId,
      classId: input.classId,
      schoolId,
    })),
    skipDuplicates: true, // Don't fail if already enrolled
  });

  revalidatePath("/students");
  revalidatePath("/classes");
  return { success: true, count: input.studentIds.length };
}
```

---

## Dashboard Drill-Down

Make dashboard stats clickable to navigate to filtered listings:

```typescript
// stats-card.tsx - Clickable stat card
import Link from "next/link";

interface StatCardProps {
  title: string;
  value: number;
  href?: string;  // Optional link to listing
  locale: string;
}

export function StatCard({ title, value, href, locale }: StatCardProps) {
  const content = (
    <Card className={href ? "cursor-pointer hover:bg-accent/50 transition-colors" : ""}>
      <CardHeader>
        <CardTitle className="text-2xl">{value}</CardTitle>
        <CardDescription>{title}</CardDescription>
      </CardHeader>
    </Card>
  );

  if (href) {
    return <Link href={`/${locale}${href}`}>{content}</Link>;
  }

  return content;
}

// Usage in dashboard
<StatCard
  title="Students"
  value={500}
  href="/students"
  locale={locale}
/>
<StatCard
  title="Active Classes"
  value={32}
  href="/classes?status=active"
  locale={locale}
/>
```

---

## Common Relationship Patterns

### Student â†” Class (Many-to-Many via StudentClass)

```typescript
// Get student's classes
const studentClasses = await db.studentClass.findMany({
  where: { studentId, schoolId },
  include: {
    class: {
      include: { subject: true, teacher: true }
    }
  }
});

// Get class's students
const classStudents = await db.studentClass.findMany({
  where: { classId, schoolId },
  include: { student: true }
});
```

### Student â†” Grades (via Result)

```typescript
// Get student's grades
const grades = await db.result.findMany({
  where: { studentId, schoolId },
  include: {
    class: true,
    assignment: true,
    exam: true,
  },
  orderBy: { createdAt: 'desc' }
});
```

### Class â†” Teacher (Direct FK)

```typescript
// Get teacher's classes
const classes = await db.class.findMany({
  where: { teacherId, schoolId },
  include: { subject: true }
});
```

---

The Listings pattern ensures consistency across all data-driven features in the platform. By following this pattern, you get auto-refresh, optimistic updates, view toggles, and export functionalityâ€”all out of the box. **Connected listings** take it further by linking related data, enabling bulk operations, and providing rich detail pages.
